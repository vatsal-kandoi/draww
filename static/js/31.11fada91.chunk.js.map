{"version":3,"file":"static/js/31.11fada91.chunk.js","mappings":"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","sources":["interfaces/canvas/actions/user.ts","interfaces/canvas/shapes/base.ts","canvas/utils/normalizeCoordinates.ts","canvas/events/base.ts","canvas/events/pen.ts","canvas/events/square.ts","canvas/managers/events.ts","canvas/managers/render.ts","canvas/managers/selection.ts","canvas/utils/shift.ts","canvas/utils/abs.ts","canvas/structures/base.ts","canvas/structures/line.ts","canvas/structures/square.ts","canvas/utils/comparePoints.ts","canvas/managers/shape.ts","canvas/worker.ts","canvas/managers/index.ts"],"sourcesContent":["import { Point } from \"../base\";\r\nimport { EventJSONBase } from \"../events/base\";\r\nimport { ShapeTypes } from \"../shapes/base\";\r\n\r\nexport enum UserAction {\r\n    SHAPE_CHANGE = \"SHAPE_CHANGE\",\r\n    INIT_USER = \"INIT_USER\",\r\n    INIT_CANVAS = \"INIT_CANVAS\",\r\n    INIT_TEMPORARY_CANVAS = \"INIT_TEMPORARY_CANVAS\",\r\n    MOUSE_MOVE_EVENT = \"MOUSE_MOVE_EVENT\",\r\n    LOAD_EVENTS = \"LOAD_EVENTS\",\r\n    DELETE_ALL_EVENTS = \"DELETE_ALL_EVENTS\",\r\n    NEW_EVENT_ADDED = \"NEW_EVENT_ADDED\",\r\n    PROPERTIES_CHANGE = \"PROPERTIES_CHANGE\"\r\n}\r\n\r\nexport interface IProperties {\r\n    borderColor: string;\r\n}\r\n\r\nexport interface IPropertiesChange extends IProperties {\r\n    action: UserAction;\r\n}\r\n\r\nexport interface IShapeChange {\r\n    action: UserAction;\r\n    shape: ShapeTypes;\r\n}\r\n\r\nexport interface IInitUser { \r\n    action: UserAction;\r\n    user_name: string;\r\n}\r\n\r\nexport interface IInitCanvas {\r\n    action: UserAction;\r\n    canvas: OffscreenCanvas;\r\n    dimensions: Point,\r\n}\r\n\r\nexport interface IInitTemporaryCanvas {\r\n    action: UserAction;\r\n    canvas: OffscreenCanvas;\r\n    dimensions: Point,\r\n}\r\n\r\nexport interface IMouseMoveEvent {\r\n    action: UserAction;\r\n    point: Point;\r\n    isMouseDown: boolean;\r\n}\r\n\r\nexport interface INewEvent {\r\n    event: EventJSONBase;\r\n}","import { Point } from \"../base\";\r\n\r\nexport interface IShapeBase {\r\n    exportToJson: () => IShapeJSONBase;\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n    shift: (from_point: Point, to_point: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSONBase {\r\n}\r\n\r\nexport enum ShapeTypes {\r\n    NONE = \"NONE\",\r\n    LINE = \"LINE\",\r\n    SQUARE = \"SQUARE\",\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { EventJSONBase, IEventBase, Point, ShapeTypes } from \"../../interfaces\";\r\n\r\nexport class EventBase implements IEventBase {\r\n    public type: ShapeTypes = ShapeTypes.NONE;    \r\n    public event_name: string;\r\n    public user_name: string;\r\n    public capture_canvas_dimensions: Point;\r\n    public current_canvas_dimensions: Point;\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string) {\r\n        this.current_canvas_dimensions = current_canvas_dimensions;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Validate if events match based on the name\r\n     * @param other IEventBase\r\n     * @returns boolean\r\n     */\r\n    public isEqual(other: IEventBase) {\r\n        return this.event_name === other.event_name;\r\n    }\r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    protected getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Render the event onto the canvas\r\n     * @param contextAPI Convext API for the canvas \r\n     */\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Export the event as a JSON object\r\n     */\r\n    public exportToJson(): EventJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n\r\n","import { IPenEvent, PenJSON, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { Line } from \"../structures/line\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport { EventBase } from \"./base\";\r\n\r\nexport class PenEvent extends EventBase implements IPenEvent {\r\n    public type: ShapeTypes = ShapeTypes.LINE;    \r\n    shape: Line[];\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string, shape: Line[]) {\r\n        super(capture_canvas_dimensions, current_canvas_dimensions, user_name);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        this.shape.forEach(line => line.render(contextAPI, this.capture_canvas_dimensions, this.current_canvas_dimensions));\r\n    }\r\n\r\n    private getPoint(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: any ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }\r\n\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n\r\n        this.shape.forEach((line) => {\r\n            from_point.x = this.getPoint(\"x\", from_point, line.from_point, Math.min);\r\n            from_point.y = this.getPoint(\"y\", from_point, line.from_point, Math.min);\r\n            from_point.x = this.getPoint(\"x\", from_point, line.to_point, Math.min);\r\n            from_point.y = this.getPoint(\"y\", from_point, line.to_point, Math.min);\r\n            \r\n            to_point.x = this.getPoint(\"x\", to_point, line.from_point, Math.max);\r\n            to_point.y = this.getPoint(\"y\", to_point, line.from_point, Math.max);\r\n            to_point.x = this.getPoint(\"x\", to_point, line.to_point, Math.max);\r\n            to_point.y = this.getPoint(\"y\", to_point, line.to_point, Math.max);\r\n        });\r\n\r\n        return { from_point, to_point };\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D) {        \r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(contextAPI);\r\n\r\n        contextAPI.setLineDash([6]);\r\n        contextAPI.strokeStyle = \"#000\";\r\n        contextAPI.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        contextAPI.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.forEach((line) => {\r\n            line.shift(from_point, to_point);\r\n        })\r\n    }\r\n\r\n    public exportToJson(): PenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            current_canvas_dimensions: this.current_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n}\r\n","import { ISquareEvent, SquareJSON, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { Square } from \"../structures/square\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport { EventBase } from \"./base\";\r\n\r\nexport class SquareEvent extends EventBase implements ISquareEvent {\r\n    public type: ShapeTypes = ShapeTypes.LINE;    \r\n    shape: Square;\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string, shape: Square) {\r\n        super(capture_canvas_dimensions, current_canvas_dimensions, user_name);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        this.shape.render(contextAPI, this.capture_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    private getPoint(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: any ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }\r\n\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n        \r\n        from_point.x = this.getPoint(\"x\", from_point, this.shape.from_point, Math.min);\r\n        from_point.y = this.getPoint(\"y\", from_point, this.shape.from_point, Math.min);\r\n        from_point.x = this.getPoint(\"x\", from_point, this.shape.to_point, Math.min);\r\n        from_point.y = this.getPoint(\"y\", from_point, this.shape.to_point, Math.min);\r\n            \r\n        to_point.x = this.getPoint(\"x\", to_point, this.shape.from_point, Math.max);\r\n        to_point.y = this.getPoint(\"y\", to_point, this.shape.from_point, Math.max);\r\n        to_point.x = this.getPoint(\"x\", to_point, this.shape.to_point, Math.max);\r\n        to_point.y = this.getPoint(\"y\", to_point, this.shape.to_point, Math.max);\r\n        \r\n        return { from_point, to_point };\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D) {        \r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(contextAPI);\r\n\r\n        contextAPI.setLineDash([6]);\r\n        contextAPI.strokeStyle = \"#000\";\r\n        contextAPI.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        contextAPI.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.shift(from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): SquareJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            current_canvas_dimensions: this.current_canvas_dimensions,\r\n            shape: this.shape.exportToJson(),\r\n        }\r\n    }\r\n}\r\n","import { Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { PenEvent } from \"../events/pen\";\r\nimport { SquareEvent } from \"../events/square\";\r\nimport { ShapeBase } from \"../structures/base\";\r\nimport { Line } from \"../structures/line\";\r\nimport { Square } from \"../structures/square\";\r\n\r\nconst DEFAULT_POINT: Point = { x: -1, y: -1 };\r\n\r\nexport class EventManager {\r\n \r\n    user_name: string | null =  null;\r\n    events: EventBase[] = [];\r\n    current_canvas_dimensions: Point = DEFAULT_POINT;\r\n\r\n    public initialiseCanvas(dimensions: Point) {\r\n        this.current_canvas_dimensions = dimensions;\r\n    }    \r\n    public initialiseUser(user_name: string) {\r\n        this.user_name = user_name;\r\n    }    \r\n\r\n    public getEventAgainstPoint(point: Point): EventBase | null {\r\n        let event: EventBase | null = null;        \r\n        for (let idx = this.events.length - 1; idx >= 0; idx-- ) {\r\n            if (this.events[idx].containsPoint(point)) {\r\n                event = this.events[idx];\r\n                break;\r\n            }\r\n        }\r\n        return event;\r\n    }\r\n\r\n    public updateEventAfterMove(event: EventBase) {\r\n        this.events = this.events.filter((evt) => evt.event_name !== event.event_name);\r\n        this.events.push(event);\r\n    }\r\n\r\n    public isInitialised(): boolean {\r\n        return this.user_name !== null;\r\n    }\r\n\r\n    public createEvent(shapeType: ShapeTypes, shape: ShapeBase | ShapeBase[]): EventBase | null {\r\n        if (this.user_name === null) return null;\r\n\r\n        switch (shapeType) {\r\n            case ShapeTypes.LINE: {\r\n                const event = new PenEvent(this.current_canvas_dimensions, this.current_canvas_dimensions, this.user_name, shape as Line[]);\r\n                this.events.push(event);\r\n                return event;\r\n            }\r\n            case ShapeTypes.SQUARE: {\r\n                const event = new SquareEvent(this.current_canvas_dimensions, this.current_canvas_dimensions, this.user_name, shape as Square);\r\n                this.events.push(event);\r\n                return event;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","import { IProperties, Point } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { ShapeBase } from \"../structures/base\";\r\n\r\nconst DEFAULT_POINT = { x: -1, y: -1 };\r\n\r\nexport class RenderManager {\r\n    public offscreen_temporary_canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    private offscreen_canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    public current_canvas_dimensions: Point = DEFAULT_POINT;    \r\n\r\n    public initialiseCanvas(canvas: OffscreenCanvas, dimensions: Point) {\r\n        const context = canvas.getContext(\"2d\") \r\n        if (context=== null) return;\r\n        this.offscreen_canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }    \r\n\r\n    public initialiseLayer(canvas: OffscreenCanvas, dimensions: Point) {\r\n        const context = canvas.getContext(\"2d\") \r\n        if (context=== null) return;\r\n        this.offscreen_temporary_canvas = context as OffscreenCanvasRenderingContext2D;\r\n    }\r\n    public renderShape(shape: ShapeBase): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        shape.render(this.offscreen_canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    public renderShapeOnLayer(shape: ShapeBase): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        shape.render(this.offscreen_temporary_canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    public selectEvent(event: EventBase): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        event.select(this.offscreen_temporary_canvas);\r\n    }\r\n\r\n    public renderEvent(event: EventBase): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        event.render(this.offscreen_canvas);\r\n    }\r\n\r\n    public renderEventOnLayer(event: EventBase): void {\r\n        this.clearLayer();\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        event.render(this.offscreen_temporary_canvas);\r\n    }    \r\n\r\n    public clearLayer(): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        this.offscreen_temporary_canvas.clearRect(0, 0, this.current_canvas_dimensions.x, this.current_canvas_dimensions.y);\r\n    }\r\n\r\n    public clearCanvas(): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        this.offscreen_canvas.clearRect(0, 0, this.current_canvas_dimensions.x, this.current_canvas_dimensions.y);\r\n    }    \r\n}","import { IProperties, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport abs from \"../utils/abs\";\r\nimport { EventManager } from \"./events\";\r\nimport { RenderManager } from \"./render\";\r\n\r\nconst DEFAULT_POINT = { x: -1, y: -1 };\r\n\r\n\r\nexport class SelectionManager {\r\n    public active_shape: ShapeTypes = ShapeTypes.NONE;\r\n    public renderManager: RenderManager;\r\n    public eventManager: EventManager;\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private active_event: EventBase | null = null;\r\n    private is_mouse_down: boolean = false;\r\n\r\n\r\n    constructor(eventManager: EventManager, renderManager: RenderManager) {\r\n        this.renderManager = renderManager;\r\n        this.eventManager = eventManager;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        if (this.active_event !== null) {\r\n            this.renderManager.renderEvent(this.active_event);\r\n        }\r\n        this.active_event = null;\r\n        this.renderManager.clearLayer();\r\n    }\r\n\r\n    public isEnabled(): boolean {\r\n        return this.active_shape === ShapeTypes.NONE;\r\n    }\r\n\r\n    public onSelectedShapeChange(selected_shape: ShapeTypes) {\r\n        this.active_shape = selected_shape;\r\n        this.reset();\r\n    }\r\n\r\n    public isShiftingEvent(point: Point): boolean {\r\n        return this.active_event !== null && this.is_mouse_down;\r\n    }\r\n\r\n    private shiftingShape(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (isMouseDown) {\r\n            if (this.active_event === null) return null;\r\n            this.active_event.shift(this.last_coordinates, point);\r\n            this.renderManager.renderEventOnLayer(this.active_event);\r\n            this.last_coordinates = point;\r\n            return null;\r\n        } else {\r\n            // Compelte shifting\r\n            if (this.active_event === null) return null;\r\n            const event = this.active_event;\r\n            this.eventManager.updateEventAfterMove(event);\r\n            this.selectEvent(event, point);\r\n            this.is_mouse_down = false;\r\n            return event;\r\n        }\r\n    }\r\n\r\n    private selectEvent(event: EventBase, point: Point) {\r\n        this.renderManager.clearLayer();\r\n        this.renderManager.clearCanvas();\r\n        const remainingEvents = this.eventManager.events.filter((ev) => ev.event_name !== event.event_name);\r\n        remainingEvents.forEach((ev) => {\r\n            this.renderManager.renderEvent(ev);\r\n        });\r\n\r\n        this.renderManager.selectEvent(event);\r\n\r\n        this.active_event = event;\r\n        this.last_coordinates = point;\r\n        this.is_mouse_down = true;        \r\n    }\r\n\r\n    private deselectEvent() {\r\n        this.renderManager.clearLayer();\r\n        this.renderManager.clearCanvas();\r\n        this.eventManager.events.forEach((ev) => {\r\n            this.renderManager.renderEvent(ev);\r\n        });\r\n        this.active_event = null;\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return null;\r\n    }\r\n\r\n    private selectingShape(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (isMouseDown) {\r\n            // Select event\r\n            const event = this.eventManager.getEventAgainstPoint(point);\r\n            console.log(event);\r\n            if (event !== null) this.selectEvent(event, point);\r\n            else this.deselectEvent();\r\n\r\n            return event;\r\n        } else {\r\n            this.is_mouse_down = false;\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (this.isShiftingEvent(point)) return this.shiftingShape(point, isMouseDown);\r\n        else return this.selectingShape(point, isMouseDown);\r\n    }\r\n    \r\n}","import { Point } from \"../../interfaces\";\r\nimport abs from \"./abs\";\r\n\r\nexport default function shift(point: Point, from_center: Point, to_center: Point): Point {\r\n    const ratio = abs((from_center.y - point.y) / (from_center.x - point.x));\r\n    const distance = Math.sqrt(Math.pow( from_center.y - point.y, 2) +  Math.pow(from_center.x - point.x, 2))\r\n    const c = distance / Math.sqrt( ( Math.pow(ratio, 2) + 1 ))\r\n\r\n    const multiplier = {\r\n        x: point.x < from_center.x ? -1 : 1,\r\n        y: point.y < from_center.y ? -1 : 1,\r\n    }\r\n\r\n    return {\r\n        x: to_center.x + multiplier.x * c,\r\n        y: to_center.y + multiplier.y * ratio * c\r\n\r\n\r\n    }\r\n}","export default function abs(num: number): number {\r\n    if (num < 0)\r\n        return -1 * num;\r\n    return num;\r\n}","import { IShapeBase, IShapeJSONBase, Point } from \"../../interfaces\";\r\n\r\nexport class ShapeBase implements IShapeBase {\r\n    public exportToJson(): IShapeJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }    \r\n}","import { ILine, LineJSON, Point } from \"../../interfaces\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport shift from \"../utils/shift\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n        context.strokeStyle = this.border_color;\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): LineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}","import { ISquare, SquareShapeJSON, Point } from \"../../interfaces\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport shift from \"../utils/shift\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\nexport class Square extends ShapeBase implements ISquare {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        context.strokeStyle = this.border_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        );                     \r\n    }    \r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): SquareShapeJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}\r\n\r\n","import { Point } from \"../../interfaces\";\r\n\r\nexport default function comparePoints(p1: Point, p2: Point) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}","import { IProperties, IPropertiesChange, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { ShapeBase } from \"../structures/base\";\r\nimport { Line } from \"../structures/line\";\r\nimport { RenderManager } from \"./render\";\r\nimport { Square } from \"../structures/square\";\r\nimport comparePoints from \"../utils/comparePoints\";\r\n\r\nconst DEFAULT_POINT: Point = { x: -1, y: -1 };\r\n\r\nexport class ShapeManager {\r\n    public active_shape: ShapeTypes = ShapeTypes.NONE;\r\n    public shape: any = null;\r\n    public renderManager: RenderManager;\r\n    private start_coordinates: Point = DEFAULT_POINT;\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private properties: IProperties = {\r\n        borderColor: \"#000\",\r\n    };\r\n\r\n    constructor(renderManager: RenderManager) {\r\n        this.renderManager = renderManager;\r\n    }\r\n\r\n    onPropertiesChange(properties: IPropertiesChange) {\r\n        this.properties = properties;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.start_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        this.shape = null;\r\n        this.renderManager.clearLayer();        \r\n    }\r\n\r\n    public isEnabled(): boolean {\r\n        return this.active_shape !== ShapeTypes.NONE;\r\n    }\r\n\r\n    public onSelectedShapeChange(selected_shape: ShapeTypes) {\r\n        this.active_shape = selected_shape;\r\n        this.reset();\r\n    }\r\n    \r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean) : ShapeBase | ShapeBase[] | null  {\r\n        let shape = null;\r\n        switch(this.active_shape) {\r\n            case ShapeTypes.LINE: {\r\n                shape = this.captureLine(point, isMouseDown);\r\n                break;\r\n            }\r\n            case ShapeTypes.SQUARE: {\r\n                shape = this.captureSquare(point, isMouseDown);\r\n                break;\r\n            }\r\n        }\r\n        return shape;     \r\n    }\r\n\r\n    private captureLine(point: Point, isMouseDown: boolean): Line[] | null {\r\n        if (comparePoints(this.last_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (isMouseDown) {\r\n                this.last_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n        \r\n        if (isMouseDown) {\r\n            const line = new Line(this.last_coordinates, point, this.properties.borderColor);\r\n                \r\n            if (this.shape === null)    \r\n                this.shape = [];\r\n\r\n            this.shape.push(line);\r\n            this.renderManager.renderShapeOnLayer(line);\r\n            this.last_coordinates = point;\r\n\r\n            return null;\r\n        }\r\n        const shape = (this.shape !== null) ? this.shape : null;\r\n\r\n        this.reset();\r\n        (shape as Line[])?.forEach((line) => this.renderManager.renderShape(line));\r\n\r\n        return shape;\r\n    }\r\n\r\n    private captureSquare(point: Point, isMouseDown: boolean): Square | null {\r\n        if (comparePoints(this.start_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (isMouseDown) {\r\n                this.start_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n        \r\n        if (isMouseDown) {\r\n            this.renderManager.clearLayer();\r\n            const square = new Square(this.start_coordinates, point, this.properties.borderColor);\r\n                \r\n            this.shape = square;\r\n            this.renderManager.renderShapeOnLayer(square);\r\n\r\n            return null;\r\n        }\r\n        const shape = (this.shape !== null) ? this.shape : null;\r\n\r\n        this.reset();\r\n        this.renderManager.renderShape(shape);\r\n\r\n        return shape;\r\n    }\r\n}","import { IInitCanvas, IMouseMoveEvent, IInitUser, UserAction, IShapeChange, INewEvent, IInitTemporaryCanvas, IPropertiesChange } from \"../interfaces\";\r\nimport { Manager } from \"./managers\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as { action: UserAction, [key: string]: any };\r\n\r\n    switch (data.action) {\r\n        case UserAction.INIT_USER: {        \r\n            manager.onUserInit((data as IInitUser).user_name);\r\n            break;\r\n        } \r\n        case UserAction.INIT_CANVAS: {\r\n            manager.onCanvasInit(\r\n                (data as IInitCanvas).canvas, \r\n                (data as IInitCanvas).dimensions\r\n            );\r\n            break;\r\n        }\r\n        case UserAction.INIT_TEMPORARY_CANVAS: {\r\n            manager.onTemporaryCanvasInit(\r\n                (data as IInitTemporaryCanvas).canvas, \r\n                (data as IInitTemporaryCanvas).dimensions\r\n            );\r\n            break;\r\n        }\r\n        case UserAction.SHAPE_CHANGE: {\r\n            manager.onSelectedShapeChange((data as IShapeChange).shape);\r\n            break;\r\n        }\r\n        case UserAction.MOUSE_MOVE_EVENT: {\r\n            const event = manager.onMouseMoveEvent(\r\n                (data as IMouseMoveEvent).point,\r\n                (data as IMouseMoveEvent).isMouseDown\r\n            );\r\n            if (event !== null) {\r\n                postMessage({\r\n                    type: UserAction.NEW_EVENT_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as INewEvent);\r\n            }\r\n            break;\r\n        }\r\n        case UserAction.PROPERTIES_CHANGE: {\r\n            manager.onPropertiesChange((data as IPropertiesChange));\r\n            break;\r\n        }\r\n    }\r\n};","import {  IProperties, IPropertiesChange, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { EventManager } from \"./events\";\r\nimport { RenderManager } from \"./render\";\r\nimport { SelectionManager } from \"./selection\";\r\nimport { ShapeManager } from \"./shape\";\r\n\r\n\r\nexport class Manager {\r\n\r\n    eventManager: EventManager = new EventManager();\r\n    renderManager: RenderManager = new RenderManager();\r\n    shapeManager: ShapeManager = new ShapeManager(this.renderManager);\r\n    selectionManager: SelectionManager = new SelectionManager(this.eventManager, this.renderManager);\r\n\r\n    public onUserInit(user_name: string): void {\r\n        this.eventManager.initialiseUser(user_name);\r\n    }\r\n\r\n    public onCanvasInit(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        this.eventManager.initialiseUser(\"Vatsal\");\r\n        this.renderManager.initialiseCanvas(canvas, dimensions);\r\n        this.eventManager.initialiseCanvas(dimensions);\r\n    }\r\n\r\n    public onTemporaryCanvasInit(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        this.renderManager.initialiseLayer(canvas, dimensions);\r\n    }\r\n\r\n    public onSelectedShapeChange(selectedShape: ShapeTypes): void {\r\n        this.shapeManager.onSelectedShapeChange(selectedShape);\r\n        this.selectionManager.onSelectedShapeChange(selectedShape);\r\n    }\r\n\r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): null | EventBase {\r\n        if (this.selectionManager.isEnabled()) return this.onMouseMoveForSelection(point, isMouseDown);\r\n        return this.onMouseMoveForDraw(point, isMouseDown);\r\n    }\r\n\r\n    private onMouseMoveForSelection(point: Point, isMouseDown: boolean): null | EventBase {\r\n        const event = this.selectionManager.onMouseMoveEvent(point, isMouseDown);\r\n        return event;\r\n    }\r\n\r\n    private onMouseMoveForDraw(point: Point, isMouseDown: boolean): null | EventBase {\r\n        const shape = this.shapeManager.onMouseMoveEvent(point, isMouseDown);\r\n\r\n        if (shape === null)\r\n            return null;\r\n\r\n        const event = this.eventManager.createEvent(this.shapeManager.active_shape, shape)\r\n        return event;\r\n    }\r\n\r\n    public onPropertiesChange(properties: IPropertiesChange) {\r\n        this.shapeManager.onPropertiesChange(properties);\r\n    }\r\n}"],"names":["UserAction","ShapeTypes","normalizeCoordinates","coords","currentDimensions","captureDimensions","x","y","EventBase","constructor","capture_canvas_dimensions","current_canvas_dimensions","user_name","type","NONE","event_name","this","getNewEventID","isEqual","other","result","characters","counter","charAt","Math","floor","random","render","contextAPI","Error","select","containsPoint","point","shift","from_point","to_point","exportToJson","PenEvent","shape","super","LINE","forEach","line","getPoint","axis","existing","candidate","func","getBoundingRect","min","max","fromCoords","toCoords","setLineDash","strokeStyle","strokeRect","map","SquareEvent","DEFAULT_POINT","EventManager","events","initialiseCanvas","dimensions","initialiseUser","getEventAgainstPoint","event","idx","length","updateEventAfterMove","filter","evt","push","isInitialised","createEvent","shapeType","SQUARE","RenderManager","offscreen_temporary_canvas","offscreen_canvas","canvas","context","getContext","initialiseLayer","renderShape","renderShapeOnLayer","selectEvent","renderEvent","renderEventOnLayer","clearLayer","clearRect","clearCanvas","SelectionManager","eventManager","renderManager","active_shape","last_coordinates","active_event","is_mouse_down","reset","isEnabled","onSelectedShapeChange","selected_shape","isShiftingEvent","shiftingShape","isMouseDown","ev","deselectEvent","selectingShape","console","log","onMouseMoveEvent","from_center","to_center","ratio","num","c","sqrt","pow","multiplier","ShapeBase","Line","border_color","beginPath","moveTo","lineTo","closePath","stroke","Square","comparePoints","p1","p2","ShapeManager","start_coordinates","properties","borderColor","onPropertiesChange","captureLine","captureSquare","square","manager","shapeManager","selectionManager","onUserInit","onCanvasInit","onTemporaryCanvasInit","selectedShape","onMouseMoveForSelection","onMouseMoveForDraw","onmessage","e","data","action","INIT_USER","INIT_CANVAS","INIT_TEMPORARY_CANVAS","SHAPE_CHANGE","MOUSE_MOVE_EVENT","postMessage","NEW_EVENT_ADDED","PROPERTIES_CHANGE"],"sourceRoot":""}