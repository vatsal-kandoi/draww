{"version":3,"file":"static/js/355.b766a9d9.chunk.js","mappings":"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","sources":["interfaces/structures/base/point.ts","interfaces/structures/shapes/base.ts","interfaces/actions/user/types.ts","interfaces/canvas/properties/stroke.ts","interfaces/canvas/properties/user.ts","canvas/managers/shapes/base.ts","utils/canvas/comparePoints.ts","canvas/store.ts","canvas/render.ts","utils/canvas/normalizeCoordinates.ts","canvas/structures/shapes/base.ts","utils/canvas/shift.ts","utils/numeric/abs.ts","canvas/structures/shapes/line.ts","canvas/structures/events/base.ts","canvas/structures/events/pen.ts","canvas/managers/shapes/pen.ts","canvas/structures/shapes/square.ts","canvas/structures/events/square.ts","canvas/managers/shapes/square.ts","canvas/managers/capture.ts","canvas/managers/selection.ts","canvas/worker.ts","canvas/manager.ts","canvas/structures/events/index.ts"],"sourcesContent":["/** Defines the point / width & height of a interface */\r\nexport interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport const DEFAULT_POINT: Point = {\r\n    x: -1,\r\n    y: -1\r\n}","import { Point } from \"../base/point\";\r\n\r\n/** Shapes that can be selected by the user */\r\nexport enum Shapes {\r\n    NONE = \"NONE\",\r\n    PEN = \"PEN\",\r\n    SQUARE = \"SQUARE\",\r\n}\r\n\r\nexport interface IShape {\r\n    /** Export the shape to a JSON to be serialized & stored. Also can be downloaded by the user to be exported / sent to\r\n     * external people\r\n     */\r\n    exportToJson: () => IShapeJSON;\r\n    /**\r\n     * Render the shape onto the HTML canvas\r\n     * @param context HTML 2D context\r\n     * @param capture_canvas_dimensions Dimensions in which shape was captured \r\n     * @param current_canvas_dimensions Dimensions of the current canvas. The shape is rendered in a normalized fashion\r\n     */\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n    /**\r\n     * Shift the current shape to a new position based on the previous click & new click position ( drags )\r\n     * @param from_point Previous click position\r\n     * @param to_point New click position\r\n     */\r\n    shift: (from_point: Point, to_point: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSON { }\r\n\r\n","/** Defines interactions performed between canvas worker and the user */\r\nexport enum UserCanvasActionType {\r\n    CANVAS_INITIALIZE_USER = \"CANVAS_INITIALIZE_USER\",\r\n    CANVAS_INITIALIZE_MAIN_CANVAS = \"CANVAS_INITIALIZE_MAIN_CANVAS\",\r\n    CANVAS_INITIALIZE_TEMPORARY_LAYER = \"CANVAS_INITIALIZE_TEMPORARY_LAYER\",\r\n    \r\n    CANVAS_CHANGE_SELECTED_SHAPE = \"CANVAS_CHANGE_SELECTED_SHAPE\",\r\n    CANVAS_CHANGE_MOUSE_POSITION = \"CANVAS_CHANGE_MOUSE_POSITION\",\r\n    CANVAS_CHANGE_DRAWING_PROPERTIES = \"CANVAS_CHANGE_DRAWING_PROPERTIES\",\r\n    CANVAS_CHANGE_THEME_BASED_PROPERTIES = \"CANVAS_CHANGE_THEME_BASED_PROPERTIES\",\r\n\r\n    CANVAS_EVENTS_ADDED = \"CANVAS_EVENTS_ADDED\",\r\n    CANVAS_EVENTS_LOAD = \"CANVAS_EVENTS_LOAD\",\r\n    CANVAS_EVENTS_DELETE_ALL = \"CANVAS_EVENTS_DELETE_ALL\",\r\n\r\n    CANVAS_PLAYER_MODE_RENDER_EVENT = \"CANVAS_PLAYER_MODE_RENDER_EVENT\",\r\n    CANVAS_PLAYER_MODE_CLEAR_ALL_EVENTS = \"CANVAS_PLAYER_MODE_CLEAR_ALL_EVENTS\",\r\n\r\n}\r\n","export enum StrokeStyles {\r\n    SOLID = \"SOLID\",\r\n    DASH = \"DASH\",\r\n    DOTTED = \"DOTTED\"\r\n}","import { StrokeStyles } from \"./stroke\";\r\n\r\nexport interface ICanvasUserEventProperties {\r\n    /** Color assigned to the border strokes */\r\n    border_color: string;\r\n    /** Style of border line */\r\n    stroke_style: StrokeStyles;\r\n}\r\nexport const DEFAULT_CANVAS_PROPERTIES: ICanvasUserEventProperties = {\r\n    border_color: \"#000\",\r\n    stroke_style: StrokeStyles.SOLID,\r\n}","import { DEFAULT_CANVAS_PROPERTIES, ICanvasUserEventProperties, IUserEvent, Point } from \"../../../interfaces\";\r\n\r\nexport class ShapeCaptureManagerBase {\r\n    properties: ICanvasUserEventProperties = DEFAULT_CANVAS_PROPERTIES;\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        throw new Error(\"Not implemented\")\r\n    }\r\n\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport default function comparePoints(p1: Point, p2: Point) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}","import { IUserEvent } from \"../interfaces\";\r\n\r\nexport class EventStore {\r\n    private static instance: EventStore;\r\n\r\n    private events: IUserEvent[] = [];\r\n\r\n    /**\r\n     * Get all user events currently in store\r\n     * @returns All user events\r\n     */\r\n    public getAllEvents(): IUserEvent[] {\r\n        return this.events;\r\n    }\r\n\r\n    /** Remove all events from the store */\r\n    public reset() {\r\n        this.events = [];\r\n    }\r\n\r\n    /**\r\n     * Update the event in the store\r\n     * @param event Event to be updated\r\n     */\r\n    public updateEvent(event: IUserEvent) {\r\n        this.events = this.events.filter((evt) => evt.event_name !== event.event_name);\r\n        this.events.push(event);        \r\n    }\r\n\r\n    /**\r\n     * Add the user event to the store\r\n     * @param event Event to be added\r\n     */\r\n    public addEvent(event: IUserEvent) {\r\n        this.events.push(event);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the event store\r\n     * @returns Event store instance\r\n     */\r\n    public static getInstance(): EventStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new EventStore();\r\n\r\n        return this.instance;\r\n    }\r\n}\r\n\r\nexport class UserStore {\r\n    private static instance: UserStore;\r\n\r\n    private user_name: string = \"\";\r\n\r\n    /**\r\n     * Set the user name\r\n     * @param user_name user name\r\n     */\r\n    public setUserName(user_name: string): void {\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the user name\r\n     * @returns User name\r\n     */\r\n    public getUserName(): string {\r\n        return this.user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the store\r\n     * @returns User store instance\r\n     */\r\n    public static getInstance(): UserStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new UserStore();\r\n\r\n        return this.instance;\r\n    }\r\n}","import { DEFAULT_POINT, IShape, IUserEvent, Point } from \"../interfaces\";\r\nimport { ShapeBase } from \"./structures/shapes/base\";\r\nimport { EventStore } from \"./store\";\r\n\r\ninterface OnLayerObjects {\r\n    /** Events on layer & not on canvas */\r\n    events: IUserEvent[]; \r\n    /** Shapes on layer & not on canvas */\r\n    shapes: IShape[];\r\n}\r\n\r\nexport class Renderer {\r\n    private static instance: Renderer;\r\n\r\n    /** HTML offscreen canvas */\r\n    canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Temporary HTML offscreen layer */\r\n    layer: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Canvas dimensions */\r\n    current_canvas_dimensions: Point = DEFAULT_POINT;\r\n    /** Events & shapes on layer and not on canvas */\r\n    currently_on_layer: OnLayerObjects = {\r\n        events: [],\r\n        shapes: [],\r\n    };\r\n    /** Outline color for the selection border box */\r\n    select_outline_color: string = \"#000\"\r\n\r\n\r\n    /**\r\n     * Initialise the canvas and store the context\r\n     * @param canvas HTML offscreen canvas\r\n     * @param dimensions canvas dimensions\r\n     */\r\n    public initializeCanvas(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }\r\n\r\n    /**\r\n     * Initialise the canvas and store the context for the temporary layer\r\n     * @param canvas HTML offscreen canvas for the layer\r\n     */\r\n    public initializeLayer(canvas: OffscreenCanvas) {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.layer = context as OffscreenCanvasRenderingContext2D;\r\n    }\r\n\r\n    /**\r\n     * Initialize the outline color\r\n     * @param color Color to be selected\r\n     */\r\n    public initializeSelectOutlineColor(color: string) {\r\n        this.select_outline_color = color;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Get the renderer instance\r\n     * @returns Renderer instance\r\n     */\r\n    public static getInstance(): Renderer {\r\n        if (this.instance === undefined)\r\n            this.instance = new Renderer();\r\n\r\n        return this.instance;\r\n    }\r\n\r\n    /**\r\n     * Render the event on the main canvas\r\n     * @param event User event\r\n     */\r\n    public renderEvent(event: IUserEvent): void {\r\n        if (this.canvas === null) return;\r\n        event.render(this.canvas, this.current_canvas_dimensions);\r\n    }\r\n\r\n    /**\r\n     * Render the shape on the temporary layer\r\n     * @param shape Shape\r\n     */\r\n    public renderShape(shape: ShapeBase): void {\r\n        if (this.layer === null) return;\r\n        shape.render(this.layer, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        this.currently_on_layer.shapes.push(shape);\r\n    }\r\n\r\n    /**\r\n     * Push the objects in the temporary layer onto the canvas\r\n     */\r\n    public pushObjectsOntoCanvas(): void {\r\n        this.currently_on_layer.events.forEach((event) => {\r\n            if(this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n        this.currently_on_layer.shapes.forEach((shape) => {\r\n            if(this.canvas === null) return;\r\n            shape.render(this.canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        })\r\n        this.clearLayer();\r\n    }\r\n\r\n    /**\r\n     * Select the event by rendering it on the temporary layer and render remaining events on the main\r\n     * canvas\r\n     * @param event User event\r\n     */\r\n    public select(event: IUserEvent) {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((ev: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            if (!ev.isEqual(event))\r\n                ev.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** Shift the event & render the shifted event on the layer */\r\n    public shift(event: IUserEvent) {\r\n        this.clearLayer();\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** \r\n     * Render all the events in the store\r\n     */\r\n    public renderAllEvents(): void {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((event: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events\r\n    */\r\n    public clearCanvas() {\r\n        if (this.canvas === null) return;\r\n        this.clearContext(this.canvas);\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events & shapes\r\n    */\r\n    public clearLayer() {   \r\n        if (this.layer === null) return;\r\n        this.clearContext(this.layer);\r\n        this.currently_on_layer = {events: [], shapes: []};\r\n    }\r\n\r\n    /**\r\n     * Clear the context of any events & shapes\r\n     * @param context HTML canvas offscreen 2D context\r\n     */\r\n    private clearContext(context: OffscreenCanvasRenderingContext2D) {\r\n        context.clearRect(\r\n            0,\r\n            0,\r\n            this.current_canvas_dimensions.x,\r\n            this.current_canvas_dimensions.y\r\n        )\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { IShape, IShapeJSON, Point, StrokeStyles } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all shapes available to the user */\r\nexport class ShapeBase implements IShape {\r\n\r\n    public exportToJson(): IShapeJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }    \r\n\r\n    public static fromJson(data: IShapeJSON): IShape {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public getLineDashForStrokeStyle(style: StrokeStyles): number {\r\n        switch(style) {\r\n            case (StrokeStyles.SOLID): {\r\n                return 0;\r\n            } \r\n            case (StrokeStyles.DOTTED): {\r\n                return 1;\r\n            }\r\n            case (StrokeStyles.DASH): {\r\n                return 6;\r\n            }\r\n            default: {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\nimport abs from \"../numeric/abs\";\r\n\r\nexport function shift(point: Point, from_center: Point, to_center: Point): Point {\r\n    const ratio = abs((from_center.y - point.y) / (from_center.x - point.x));\r\n    const distance = Math.sqrt(Math.pow( from_center.y - point.y, 2) +  Math.pow(from_center.x - point.x, 2))\r\n    const c = distance / Math.sqrt( ( Math.pow(ratio, 2) + 1 ))\r\n\r\n    const multiplier = {\r\n        x: point.x < from_center.x ? -1 : 1,\r\n        y: point.y < from_center.y ? -1 : 1,\r\n    }\r\n\r\n    return {\r\n        x: to_center.x + multiplier.x * c,\r\n        y: to_center.y + multiplier.y * ratio * c\r\n    }\r\n}","export default function abs(num: number): number {\r\n    if (num < 0)\r\n        return -1 * num;\r\n    return num;\r\n}","import { ShapeBase } from \"./base\";\r\nimport { ILine, ILineJSON, Point } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\n\r\n/** Defines the class for line shape available to the user */\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n\r\n        context.setLineDash([0]);\r\n        context.strokeStyle = this.border_color;\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ILineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n\r\n    public static fromJson(data: ILineJSON): Line {        \r\n        const line = new Line(\r\n            data.from_point,\r\n            data.to_point,\r\n            data.border_color\r\n        );\r\n        return line;\r\n    }\r\n}","import { IShape, IUserEvent, IUserEventJSON, Point, Shapes } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all events generated by the user */\r\nexport class UserEventBase implements IUserEvent {\r\n    \r\n    type: Shapes = Shapes.NONE;\r\n    event_name: string;\r\n    user_name: string;\r\n    shape: IShape | IShape[];\r\n    capture_canvas_dimensions: Point;\r\n    \r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: IShape | IShape[]) {\r\n        this.shape = shape;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    public isEqual(other: IUserEvent) {\r\n        return this.event_name === other.event_name;\r\n    }    \r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public exportToJson(): IUserEventJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public containsPoint (point: Point): boolean {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    \r\n    public shift (from_point: Point, to_point: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public static fromJson(data: IUserEventJSON): IUserEvent {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the axis value based on existing & candidate points based on the Math max or min function\r\n     * @param axis Axis x or y\r\n     * @param existing Existing point\r\n     * @param candidate POint to be considered\r\n     * @param func Max or min function\r\n     * @returns new axis value\r\n     */\r\n    protected getAxisValue(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: typeof Math.min | typeof Math.max ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }    \r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    private getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n","import { ILine, IUserPenEvent, IUserPenJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { Line } from \"../shapes/line\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the freeform pen draw event by the yser*/\r\nexport class UserPenEvent extends UserEventBase implements IUserPenEvent {\r\n    public type: Shapes = Shapes.PEN;    \r\n    shape: ILine[];    \r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ILine[]) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n    \r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.forEach(line => line.render(context, this.capture_canvas_dimensions, current_canvas_dimensions));\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.forEach((line) => {\r\n            line.shift(from_point, to_point);\r\n        })\r\n    }\r\n\r\n    public exportToJson(): IUserPenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n\r\n    public static fromJson(data: IUserPenJSON): IUserPenEvent {        \r\n        const event = new UserPenEvent(\r\n            data.capture_canvas_dimensions,\r\n            data.user_name,\r\n            data.shape.map((shapeJson) => Line.fromJson(shapeJson))\r\n        );\r\n        event.event_name = data.event_name;\r\n        return event;\r\n    }\r\n\r\n    /** Get the rectangle that encompasses the current set of lines in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n\r\n        this.shape.forEach((line) => {\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.from_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.from_point, Math.min);\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.to_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.to_point, Math.min);\r\n            \r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.from_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.from_point, Math.max);\r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.to_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.to_point, Math.max);\r\n        });\r\n\r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { DEFAULT_POINT, ILine, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserPenEvent } from \"../../structures/events/pen\";\r\nimport { Line } from \"../../structures/shapes/line\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class PenCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ILine[] = [];\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.last_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.last_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingLines(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingLines();\r\n        }\r\n    }\r\n    \r\n    private continueCapturingLines(point: Point) {\r\n        const line = new Line(this.last_coordinates, point, this.properties.border_color);                \r\n\r\n        this.shape.push(line);\r\n\r\n        const renderer = Renderer.getInstance()\r\n        renderer.renderShape(line);\r\n\r\n        this.last_coordinates = point;\r\n    }\r\n\r\n    private completeCapturingLines(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape.length === 0) return null;\r\n\r\n        const event = new UserPenEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n\r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);        \r\n        \r\n        this.shape = [];\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ISquare, ISquareJSON, Point, StrokeStyles } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\n/** Defines the class for square shape available to the user */\r\nexport class Square extends ShapeBase implements ISquare {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n    stroke_style: StrokeStyles;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string, stroke_style: StrokeStyles) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n        this.stroke_style = stroke_style;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n\r\n        context.setLineDash([this.getLineDashForStrokeStyle(this.stroke_style)]);\r\n        context.strokeStyle = this.border_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        );                     \r\n    }    \r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ISquareJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n            stroke_style: this.stroke_style,\r\n        }\r\n    }\r\n\r\n\r\n    public static fromJson(data: ISquareJSON): Square {        \r\n        const line = new Square(\r\n            data.from_point,\r\n            data.to_point,\r\n            data.border_color,\r\n            data.stroke_style\r\n        );\r\n        return line;\r\n    }    \r\n}\r\n\r\n","import { ISquare, IUserSquareEvent, IUserSquareJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { Square } from \"../shapes/square\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the sqaure draw event by the yser*/\r\nexport class UserSquareEvent extends UserEventBase implements IUserSquareEvent {\r\n    public type: Shapes = Shapes.SQUARE;    \r\n    shape: ISquare;\r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ISquare) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.render(context, this.capture_canvas_dimensions, current_canvas_dimensions);\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.shape.shift(from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): IUserSquareJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.exportToJson(),\r\n        }\r\n    }\r\n\r\n    public static fromJson(data: IUserSquareJSON): IUserSquareEvent {        \r\n        const event = new UserSquareEvent(\r\n            data.capture_canvas_dimensions,\r\n            data.user_name,\r\n            Square.fromJson(data.shape)\r\n        );\r\n        event.event_name = data.event_name;\r\n        return event;\r\n    }\r\n\r\n\r\n    /** Get the rectangle that encompasses the current swaure in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n        \r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.from_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.from_point, Math.min);\r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.to_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.to_point, Math.min);\r\n            \r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.from_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.from_point, Math.max);\r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.to_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.to_point, Math.max);\r\n        \r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { DEFAULT_POINT, ISquare, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserSquareEvent } from \"../../structures/events/square\";\r\nimport { Square } from \"../../structures/shapes/square\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class SquareCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private start_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ISquare | null = null;\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n     public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.start_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.start_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingSquare(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingSquare();\r\n        }\r\n    }\r\n\r\n\r\n    private continueCapturingSquare(point: Point) {\r\n        const square = new Square(this.start_coordinates, point, this.properties.border_color, this.properties.stroke_style);                \r\n\r\n        this.shape = square;\r\n        const renderer = Renderer.getInstance()\r\n        renderer.clearLayer();\r\n        renderer.renderShape(square);\r\n    }\r\n\r\n    private completeCapturingSquare(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape === null) return null;\r\n\r\n        const event = new UserSquareEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n        \r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);\r\n\r\n        this.shape = null;\r\n        this.start_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ICanvasUserEventProperties, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { ShapeCaptureManagerBase } from \"./shapes/base\";\r\nimport { PenCaptureManager } from \"./shapes/pen\";\r\nimport { SquareCaptureManager } from \"./shapes/square\";\r\n\r\nexport class CaptureManager extends ShapeCaptureManagerBase {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    /** Currently active manager capturing the shape */\r\n    active_manager: ShapeCaptureManagerBase | null = null;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape !== Shapes.NONE;\r\n    }\r\n    \r\n    /**\r\n    * Handle changes to the selected shape\r\n    * @param shape \r\n    */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.setActiveCaptureManager(shape);\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n\r\n    }\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n\r\n        if (this.active_manager !== null)\r\n            this.active_manager.onCanvasDrawingPropertiesChange(properties);\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_manager === null) return null;\r\n        return this.active_manager.onMouseMovement(point, is_mouse_down);\r\n    }\r\n\r\n    private setActiveCaptureManager(shape: Shapes){ \r\n        switch(shape) {\r\n            case (Shapes.PEN): {\r\n                this.active_manager = new PenCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            case (Shapes.SQUARE): {\r\n                this.active_manager = new SquareCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            default: {\r\n                this.active_manager = null;\r\n            }\r\n        }\r\n    }\r\n}","import { DEFAULT_POINT, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { Renderer } from \"../render\";\r\nimport { EventStore } from \"../store\";\r\n\r\nexport class SelectionManager {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    active_event: IUserEvent | null = null;\r\n    is_mouse_down: boolean = false;\r\n    last_coordinates: Point = DEFAULT_POINT;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape === Shapes.NONE;\r\n    }\r\n\r\n    /**\r\n     * Handle changes to the selected shape\r\n     * @param shape \r\n     */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.active_event = null;\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.isShiftingEvent(point)) {\r\n            const event = this.shiftEvent(point, is_mouse_down);\r\n            return event;\r\n        }\r\n        // Try selecting event\r\n        this.selectEvent(point, is_mouse_down);\r\n        return null;\r\n    }\r\n\r\n    private isShiftingEvent(point: Point): boolean {\r\n        return this.active_event !== null && this.is_mouse_down;\r\n    }    \r\n\r\n    private shiftEvent(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_event === null) return null;\r\n\r\n        const renderer = Renderer.getInstance()\r\n        if (is_mouse_down) {\r\n            // Conitnue shifting\r\n            this.active_event?.shift(this.last_coordinates, point);\r\n            renderer.shift(this.active_event);\r\n            this.last_coordinates = point;\r\n            \r\n            return null;\r\n        } else {\r\n            // Complete shifting\r\n            const event = this.active_event;\r\n            this.is_mouse_down = false;\r\n            this.last_coordinates = DEFAULT_POINT;\r\n            renderer.select(event);\r\n            return event;\r\n        }\r\n    }\r\n    private selectEvent(point: Point, is_mouse_down: boolean) {\r\n        if (is_mouse_down) {\r\n            const event = this.getEventAgainstPoint(point);\r\n            const renderer = Renderer.getInstance();\r\n\r\n            // Remove selection\r\n            if (event === null) {\r\n                this.reset();\r\n                renderer.pushObjectsOntoCanvas();\r\n            }\r\n            else if (this.active_event === null || !this.active_event.isEqual(event)) {                \r\n                this.active_event = event;\r\n                renderer.select(this.active_event);\r\n            }   \r\n\r\n            this.last_coordinates = point;\r\n            this.is_mouse_down = true;\r\n        } else {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    private getEventAgainstPoint(point: Point): IUserEvent | null {\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        let event: IUserEvent | null = null;        \r\n        for (let idx = events.length - 1; idx >= 0; idx-- ) {\r\n            if (events[idx].containsPoint(point)) {\r\n                event = events[idx];\r\n                break;\r\n            }\r\n        }\r\n        return event;\r\n    }\r\n}\r\n","import { IUserCanvasActionBase, IUserCanvasActionEventAdded, IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, UserCanvasActionType } from \"../interfaces\"\r\nimport { Manager } from \"./manager\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as IUserCanvasActionBase;\r\n\r\n    switch (data.type) {\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_USER: {\r\n            manager.initializeUser(data as IUserCanvasActionInitializeUser)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_MAIN_CANVAS: {\r\n            manager.initializeCanvas(data as IUserCanvasActionInitializeCanvas)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_TEMPORARY_LAYER: {\r\n            manager.initializeLayer(data as IUserCanvasActionInitializeLayer)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_DRAWING_PROPERTIES: {\r\n            manager.onCanvasDrawingPropertiesChange(data as IUserCanvasActionPropertiesChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_SELECTED_SHAPE: {\r\n            manager.onCanvasSelectedShapeChange(data as IUserCanvasActionShapeChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_MOUSE_POSITION: {\r\n            const event = manager.onMouseMovementOnCanvas(data as IUserCanvasActionMouseMovement)\r\n            if (event !== null) \r\n                postMessage({\r\n                    type: UserCanvasActionType.CANVAS_EVENTS_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as IUserCanvasActionEventAdded)\r\n\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_THEME_BASED_PROPERTIES: {\r\n            manager.onCanvasThemeBasedPropertiesChange(data as IUserCanvasActionThemeBasedPropertiesChange);\r\n            break;\r\n        }    \r\n    }\r\n}","import { IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, IUserEvent } from \"../interfaces\";\r\nimport { IUserPlayerActionClearEvents } from \"../interfaces/actions/user/player/clear\";\r\nimport { IUserPlayerActionRenderEvent } from \"../interfaces/actions/user/player/play\";\r\nimport { CaptureManager } from \"./managers/capture\";\r\nimport { SelectionManager } from \"./managers/selection\";\r\nimport { Renderer } from \"./render\";\r\nimport { EventStore, UserStore } from \"./store\";\r\nimport convertToUserEvent from \"./structures/events\";\r\n\r\nexport class Manager {\r\n\r\n    selection: SelectionManager = new SelectionManager();\r\n    capture: CaptureManager = new CaptureManager();\r\n\r\n    public initializeUser(data: IUserCanvasActionInitializeUser) {\r\n        const store = UserStore.getInstance();\r\n        store.setUserName(data.user_name);\r\n    }\r\n\r\n    public initializeCanvas(data: IUserCanvasActionInitializeCanvas) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeCanvas(\r\n            data.canvas,\r\n            data.dimensions,\r\n        );\r\n    }\r\n\r\n    public initializeLayer(data: IUserCanvasActionInitializeLayer) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeLayer(\r\n            data.canvas\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the drawing properties\r\n     * @param data \r\n     */\r\n    public onCanvasDrawingPropertiesChange(data: IUserCanvasActionPropertiesChange): void {\r\n        this.capture.onCanvasDrawingPropertiesChange(data.properties);\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the selected shape \r\n     * @param data \r\n     */\r\n    public onCanvasSelectedShapeChange(data: IUserCanvasActionShapeChange): void {\r\n        this.capture.onCanvasSelectedShapeChange(data.shape);\r\n        this.selection.onCanvasSelectedShapeChange(data.shape);\r\n        const renderer = Renderer.getInstance();\r\n        renderer.pushObjectsOntoCanvas();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse movement changes\r\n     * @param data \r\n     */\r\n    public onMouseMovementOnCanvas(data: IUserCanvasActionMouseMovement): IUserEvent| null {\r\n        const event_store = EventStore.getInstance();\r\n        if (this.capture.isEnabled()) {\r\n            const event =  this.capture.onMouseMovement(data.point, data.is_mouse_down);\r\n            \r\n            if (event !== null)\r\n                event_store.addEvent(event);\r\n\r\n            return event;\r\n        }\r\n\r\n        const event = this.selection.onMouseMovement(data.point, data.is_mouse_down);\r\n        if (event !== null)\r\n            event_store.updateEvent(event);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Handle changes in properties related to theme\r\n     * @param data \r\n     */\r\n    public onCanvasThemeBasedPropertiesChange(data: IUserCanvasActionThemeBasedPropertiesChange): void {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeSelectOutlineColor(\r\n            data.properties.select_outline_color,\r\n        )\r\n    }\r\n\r\n\r\n    /**\r\n     * Clear all events from the canvas & store\r\n     * @param data \r\n     */\r\n    public onCanvasClearAllEvents(data: IUserPlayerActionClearEvents) {\r\n        const event_store = EventStore.getInstance()\r\n        const renderer = Renderer.getInstance();\r\n\r\n        event_store.reset();\r\n        renderer.clearCanvas();\r\n        renderer.clearLayer();\r\n    }\r\n\r\n    /**\r\n     * Render the given event on the canvas\r\n     * @param data Event JSON\r\n     */\r\n    public onCanvasRenderEvent(data: IUserPlayerActionRenderEvent) {\r\n        const renderer = Renderer.getInstance();\r\n        const event = convertToUserEvent(data.event);\r\n\r\n        renderer.renderEvent(event);\r\n    }\r\n}","import { IUserEvent, IUserEventJSON, IUserPenJSON, IUserSquareJSON, Shapes } from \"../../../interfaces\";\r\nimport { UserPenEvent } from \"./pen\";\r\nimport { UserSquareEvent } from \"./square\";\r\n\r\nexport default function convertToUserEvent(eventJSON: IUserEventJSON): IUserEvent {\r\n    switch (eventJSON.type) {\r\n        case (Shapes.PEN): {\r\n            return UserPenEvent.fromJson(eventJSON as IUserPenJSON);\r\n        }\r\n        case (Shapes.SQUARE): {\r\n            return UserSquareEvent.fromJson(eventJSON as IUserSquareJSON);\r\n        }\r\n        default: {\r\n            throw new Error(\"Unsupported type\")\r\n        }\r\n    }\r\n}"],"names":["DEFAULT_POINT","x","y","Shapes","UserCanvasActionType","StrokeStyles","DEFAULT_CANVAS_PROPERTIES","border_color","stroke_style","SOLID","ShapeCaptureManagerBase","constructor","properties","onCanvasDrawingPropertiesChange","this","onMouseMovement","point","is_mouse_down","Error","comparePoints","p1","p2","EventStore","events","getAllEvents","reset","updateEvent","event","filter","evt","event_name","push","addEvent","getInstance","undefined","instance","UserStore","user_name","setUserName","getUserName","Renderer","canvas","layer","current_canvas_dimensions","currently_on_layer","shapes","select_outline_color","initializeCanvas","dimensions","context","getContext","initializeLayer","initializeSelectOutlineColor","color","renderEvent","render","renderShape","shape","pushObjectsOntoCanvas","forEach","clearLayer","select","clearCanvas","ev","isEqual","shift","renderAllEvents","clearContext","clearRect","normalizeCoordinates","coords","currentDimensions","captureDimensions","ShapeBase","exportToJson","capture_canvas_dimensions","from_point","to_point","fromJson","data","getLineDashForStrokeStyle","style","DOTTED","DASH","from_center","to_center","ratio","num","c","Math","sqrt","pow","multiplier","Line","super","fromCoords","toCoords","beginPath","setLineDash","strokeStyle","moveTo","lineTo","closePath","stroke","UserEventBase","type","NONE","getNewEventID","other","containsPoint","getAxisValue","axis","existing","candidate","func","result","characters","counter","charAt","floor","random","UserPenEvent","PEN","line","getBoundingRect","strokeRect","map","shapeJson","min","max","PenCaptureManager","arguments","last_coordinates","continueCapturingLines","completeCapturingLines","renderer","user_store","length","Square","UserSquareEvent","SQUARE","SquareCaptureManager","start_coordinates","continueCapturingSquare","completeCapturingSquare","square","CaptureManager","active_manager","isEnabled","onCanvasSelectedShapeChange","setActiveCaptureManager","SelectionManager","active_event","isShiftingEvent","shiftEvent","selectEvent","_this$active_event","getEventAgainstPoint","idx","manager","selection","capture","initializeUser","onMouseMovementOnCanvas","event_store","onCanvasThemeBasedPropertiesChange","onCanvasClearAllEvents","onCanvasRenderEvent","eventJSON","convertToUserEvent","onmessage","e","CANVAS_INITIALIZE_USER","CANVAS_INITIALIZE_MAIN_CANVAS","CANVAS_INITIALIZE_TEMPORARY_LAYER","CANVAS_CHANGE_DRAWING_PROPERTIES","CANVAS_CHANGE_SELECTED_SHAPE","CANVAS_CHANGE_MOUSE_POSITION","postMessage","CANVAS_EVENTS_ADDED","CANVAS_CHANGE_THEME_BASED_PROPERTIES"],"sourceRoot":""}