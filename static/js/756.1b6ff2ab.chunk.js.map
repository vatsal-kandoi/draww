{"version":3,"file":"static/js/756.1b6ff2ab.chunk.js","mappings":"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","sources":["interfaces/structures/base/point.ts","interfaces/structures/shapes/base.ts","interfaces/actions/user/types.ts","interfaces/canvas/properties/stroke.ts","interfaces/canvas/properties/user.ts","canvas/managers/shapes/base.ts","utils/canvas/comparePoints.ts","canvas/store.ts","canvas/render.ts","utils/canvas/normalizeCoordinates.ts","canvas/structures/events/base.ts","canvas/structures/events/pen.ts","canvas/structures/shapes/base.ts","utils/canvas/shift.ts","utils/numeric/abs.ts","canvas/structures/shapes/line.ts","canvas/managers/shapes/pen.ts","canvas/structures/events/square.ts","canvas/structures/shapes/square.ts","canvas/managers/shapes/square.ts","canvas/managers/capture.ts","canvas/managers/selection.ts","canvas/worker.ts","canvas/manager.ts"],"sourcesContent":["/** Defines the point / width & height of a interface */\r\nexport interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport const DEFAULT_POINT: Point = {\r\n    x: -1,\r\n    y: -1\r\n}","import { Point } from \"../base/point\";\r\n\r\n/** Shapes that can be selected by the user */\r\nexport enum Shapes {\r\n    NONE = \"NONE\",\r\n    PEN = \"PEN\",\r\n    SQUARE = \"SQUARE\",\r\n}\r\n\r\nexport interface IShape {\r\n    /** Export the shape to a JSON to be serialized & stored. Also can be downloaded by the user to be exported / sent to\r\n     * external people\r\n     */\r\n    exportToJson: () => IShapeJSON;\r\n    /**\r\n     * Render the shape onto the HTML canvas\r\n     * @param context HTML 2D context\r\n     * @param capture_canvas_dimensions Dimensions in which shape was captured \r\n     * @param current_canvas_dimensions Dimensions of the current canvas. The shape is rendered in a normalized fashion\r\n     */\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n    /**\r\n     * Shift the current shape to a new position based on the previous click & new click position ( drags )\r\n     * @param from_point Previous click position\r\n     * @param to_point New click position\r\n     */\r\n    shift: (from_point: Point, to_point: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSON { }\r\n\r\n","/** Defines interactions performed between canvas worker and the user */\r\nexport enum UserCanvasActionType {\r\n    CANVAS_INITIALIZE_USER = \"CANVAS_INITIALIZE_USER\",\r\n    CANVAS_INITIALIZE_MAIN_CANVAS = \"CANVAS_INITIALIZE_MAIN_CANVAS\",\r\n    CANVAS_INITIALIZE_TEMPORARY_LAYER = \"CANVAS_INITIALIZE_TEMPORARY_LAYER\",\r\n    \r\n    CANVAS_CHANGE_SELECTED_SHAPE = \"CANVAS_CHANGE_SELECTED_SHAPE\",\r\n    CANVAS_CHANGE_MOUSE_POSITION = \"CANVAS_CHANGE_MOUSE_POSITION\",\r\n    CANVAS_CHANGE_DRAWING_PROPERTIES = \"CANVAS_CHANGE_DRAWING_PROPERTIES\",\r\n    CANVAS_CHANGE_THEME_BASED_PROPERTIES = \"CANVAS_CHANGE_THEME_BASED_PROPERTIES\",\r\n\r\n    CANVAS_EVENTS_ADDED = \"CANVAS_EVENTS_ADDED\",\r\n    CANVAS_EVENTS_LOAD = \"CANVAS_EVENTS_LOAD\",\r\n    CANVAS_EVENTS_DELETE_ALL = \"CANVAS_EVENTS_DELETE_ALL\",\r\n}\r\n","export enum StrokeStyles {\r\n    SOLID = \"SOLID\",\r\n    DASH = \"DASH\",\r\n    DOTTED = \"DOTTED\"\r\n}","import { StrokeStyles } from \"./stroke\";\r\n\r\nexport interface ICanvasUserEventProperties {\r\n    /** Color assigned to the border strokes */\r\n    border_color: string;\r\n    /** Style of border line */\r\n    stroke_style: StrokeStyles;\r\n}\r\nexport const DEFAULT_CANVAS_PROPERTIES: ICanvasUserEventProperties = {\r\n    border_color: \"#000\",\r\n    stroke_style: StrokeStyles.SOLID,\r\n}","import { DEFAULT_CANVAS_PROPERTIES, ICanvasUserEventProperties, IUserEvent, Point } from \"../../../interfaces\";\r\n\r\nexport class ShapeCaptureManagerBase {\r\n    properties: ICanvasUserEventProperties = DEFAULT_CANVAS_PROPERTIES;\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        throw new Error(\"Not implemented\")\r\n    }\r\n\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport default function comparePoints(p1: Point, p2: Point) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}","import { IUserEvent } from \"../interfaces\";\r\n\r\nexport class EventStore {\r\n    private static instance: EventStore;\r\n\r\n    private events: IUserEvent[] = [];\r\n\r\n    /**\r\n     * Get all user events currently in store\r\n     * @returns All user events\r\n     */\r\n    public getAllEvents(): IUserEvent[] {\r\n        return this.events;\r\n    }\r\n\r\n    /**\r\n     * Update the event in the store\r\n     * @param event Event to be updated\r\n     */\r\n    public updateEvent(event: IUserEvent) {\r\n        this.events = this.events.filter((evt) => evt.event_name !== event.event_name);\r\n        this.events.push(event);        \r\n    }\r\n\r\n    /**\r\n     * Add the user event to the store\r\n     * @param event Event to be added\r\n     */\r\n    public addEvent(event: IUserEvent) {\r\n        this.events.push(event);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the event store\r\n     * @returns Event store instance\r\n     */\r\n    public static getInstance(): EventStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new EventStore();\r\n\r\n        return this.instance;\r\n    }\r\n}\r\n\r\nexport class UserStore {\r\n    private static instance: UserStore;\r\n\r\n    private user_name: string = \"\";\r\n\r\n    /**\r\n     * Set the user name\r\n     * @param user_name user name\r\n     */\r\n    public setUserName(user_name: string): void {\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the user name\r\n     * @returns User name\r\n     */\r\n    public getUserName(): string {\r\n        return this.user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the store\r\n     * @returns User store instance\r\n     */\r\n    public static getInstance(): UserStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new UserStore();\r\n\r\n        return this.instance;\r\n    }\r\n}","import { DEFAULT_POINT, IShape, IUserEvent, Point } from \"../interfaces\";\r\nimport { ShapeBase } from \"./structures/shapes/base\";\r\nimport { EventStore } from \"./store\";\r\n\r\ninterface OnLayerObjects {\r\n    /** Events on layer & not on canvas */\r\n    events: IUserEvent[]; \r\n    /** Shapes on layer & not on canvas */\r\n    shapes: IShape[];\r\n}\r\n\r\nexport class Renderer {\r\n    private static instance: Renderer;\r\n\r\n    /** HTML offscreen canvas */\r\n    canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Temporary HTML offscreen layer */\r\n    layer: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Canvas dimensions */\r\n    current_canvas_dimensions: Point = DEFAULT_POINT;\r\n    /** Events & shapes on layer and not on canvas */\r\n    currently_on_layer: OnLayerObjects = {\r\n        events: [],\r\n        shapes: [],\r\n    };\r\n    /** Outline color for the selection border box */\r\n    select_outline_color: string = \"#000\"\r\n\r\n\r\n    /**\r\n     * Initialise the canvas and store the context\r\n     * @param canvas HTML offscreen canvas\r\n     * @param dimensions canvas dimensions\r\n     */\r\n    public initializeCanvas(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }\r\n\r\n    /**\r\n     * Initialise the canvas and store the context for the temporary layer\r\n     * @param canvas HTML offscreen canvas for the layer\r\n     */\r\n    public initializeLayer(canvas: OffscreenCanvas) {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.layer = context as OffscreenCanvasRenderingContext2D;\r\n    }\r\n\r\n    /**\r\n     * Initialize the outline color\r\n     * @param color Color to be selected\r\n     */\r\n    public initializeSelectOutlineColor(color: string) {\r\n        this.select_outline_color = color;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Get the renderer instance\r\n     * @returns Renderer instance\r\n     */\r\n    public static getInstance(): Renderer {\r\n        if (this.instance === undefined)\r\n            this.instance = new Renderer();\r\n\r\n        return this.instance;\r\n    }\r\n\r\n    /**\r\n     * Render the event on the main canvas\r\n     * @param event User event\r\n     */\r\n    public renderEvent(event: IUserEvent): void {\r\n        if (this.canvas === null) return;\r\n        event.render(this.canvas, this.current_canvas_dimensions);\r\n    }\r\n\r\n    /**\r\n     * Render the shape on the temporary layer\r\n     * @param shape Shape\r\n     */\r\n    public renderShape(shape: ShapeBase): void {\r\n        if (this.layer === null) return;\r\n        shape.render(this.layer, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        this.currently_on_layer.shapes.push(shape);\r\n    }\r\n\r\n    /**\r\n     * Push the objects in the temporary layer onto the canvas\r\n     */\r\n    public pushObjectsOntoCanvas(): void {\r\n        this.currently_on_layer.events.forEach((event) => {\r\n            if(this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n        this.currently_on_layer.shapes.forEach((shape) => {\r\n            if(this.canvas === null) return;\r\n            shape.render(this.canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        })\r\n        this.clearLayer();\r\n    }\r\n\r\n    /**\r\n     * Select the event by rendering it on the temporary layer and render remaining events on the main\r\n     * canvas\r\n     * @param event User event\r\n     */\r\n    public select(event: IUserEvent) {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((ev: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            if (!ev.isEqual(event))\r\n                ev.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** Shift the event & render the shifted event on the layer */\r\n    public shift(event: IUserEvent) {\r\n        this.clearLayer();\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** \r\n     * Render all the events in the store\r\n     */\r\n    public renderAllEvents(): void {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((event: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events\r\n    */\r\n    public clearCanvas() {\r\n        if (this.canvas === null) return;\r\n        this.clearContext(this.canvas);\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events & shapes\r\n    */\r\n    public clearLayer() {   \r\n        if (this.layer === null) return;\r\n        this.clearContext(this.layer);\r\n        this.currently_on_layer = {events: [], shapes: []};\r\n    }\r\n\r\n    /**\r\n     * Clear the context of any events & shapes\r\n     * @param context HTML canvas offscreen 2D context\r\n     */\r\n    private clearContext(context: OffscreenCanvasRenderingContext2D) {\r\n        context.clearRect(\r\n            0,\r\n            0,\r\n            this.current_canvas_dimensions.x,\r\n            this.current_canvas_dimensions.y\r\n        )\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { IShape, IUserEvent, IUserEventJSON, Point, Shapes } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all events generated by the user */\r\nexport class UserEventBase implements IUserEvent {\r\n    \r\n    type: Shapes = Shapes.NONE;\r\n    event_name: string;\r\n    user_name: string;\r\n    shape: IShape | IShape[];\r\n    capture_canvas_dimensions: Point;\r\n    \r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: IShape | IShape[]) {\r\n        this.shape = shape;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    public isEqual(other: IUserEvent) {\r\n        return this.event_name === other.event_name;\r\n    }    \r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public exportToJson(): IUserEventJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public containsPoint (point: Point): boolean {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    \r\n    public shift (from_point: Point, to_point: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the axis value based on existing & candidate points based on the Math max or min function\r\n     * @param axis Axis x or y\r\n     * @param existing Existing point\r\n     * @param candidate POint to be considered\r\n     * @param func Max or min function\r\n     * @returns new axis value\r\n     */\r\n    protected getAxisValue(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: typeof Math.min | typeof Math.max ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }    \r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    private getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n","import { ILine, IUserPenEvent, IUserPenJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the freeform pen draw event by the yser*/\r\nexport class UserPenEvent extends UserEventBase implements IUserPenEvent {\r\n    public type: Shapes = Shapes.PEN;    \r\n    shape: ILine[];    \r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ILine[]) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n    \r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.forEach(line => line.render(context, this.capture_canvas_dimensions, current_canvas_dimensions));\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.forEach((line) => {\r\n            line.shift(from_point, to_point);\r\n        })\r\n    }\r\n\r\n    public exportToJson(): IUserPenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n\r\n    /** Get the rectangle that encompasses the current set of lines in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n\r\n        this.shape.forEach((line) => {\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.from_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.from_point, Math.min);\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.to_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.to_point, Math.min);\r\n            \r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.from_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.from_point, Math.max);\r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.to_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.to_point, Math.max);\r\n        });\r\n\r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { IShape, IShapeJSON, Point, StrokeStyles } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all shapes available to the user */\r\nexport class ShapeBase implements IShape {\r\n\r\n    public exportToJson(): IShapeJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }    \r\n\r\n    public getLineDashForStrokeStyle(style: StrokeStyles): number {\r\n        switch(style) {\r\n            case (StrokeStyles.SOLID): {\r\n                return 0;\r\n            } \r\n            case (StrokeStyles.DOTTED): {\r\n                return 1;\r\n            }\r\n            case (StrokeStyles.DASH): {\r\n                return 6;\r\n            }\r\n            default: {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\nimport abs from \"../numeric/abs\";\r\n\r\nexport function shift(point: Point, from_center: Point, to_center: Point): Point {\r\n    const ratio = abs((from_center.y - point.y) / (from_center.x - point.x));\r\n    const distance = Math.sqrt(Math.pow( from_center.y - point.y, 2) +  Math.pow(from_center.x - point.x, 2))\r\n    const c = distance / Math.sqrt( ( Math.pow(ratio, 2) + 1 ))\r\n\r\n    const multiplier = {\r\n        x: point.x < from_center.x ? -1 : 1,\r\n        y: point.y < from_center.y ? -1 : 1,\r\n    }\r\n\r\n    return {\r\n        x: to_center.x + multiplier.x * c,\r\n        y: to_center.y + multiplier.y * ratio * c\r\n    }\r\n}","export default function abs(num: number): number {\r\n    if (num < 0)\r\n        return -1 * num;\r\n    return num;\r\n}","import { ShapeBase } from \"./base\";\r\nimport { ILine, ILineJSON, Point } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\n\r\n/** Defines the class for line shape available to the user */\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n        context.strokeStyle = this.border_color;\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ILineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}","import { DEFAULT_POINT, ILine, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserPenEvent } from \"../../structures/events/pen\";\r\nimport { Line } from \"../../structures/shapes/line\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class PenCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ILine[] = [];\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.last_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.last_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingLines(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingLines();\r\n        }\r\n    }\r\n    \r\n    private continueCapturingLines(point: Point) {\r\n        const line = new Line(this.last_coordinates, point, this.properties.border_color);                \r\n\r\n        this.shape.push(line);\r\n\r\n        const renderer = Renderer.getInstance()\r\n        renderer.renderShape(line);\r\n\r\n        this.last_coordinates = point;\r\n    }\r\n\r\n    private completeCapturingLines(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape.length === 0) return null;\r\n\r\n        const event = new UserPenEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n\r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);        \r\n        \r\n        this.shape = [];\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ISquare, IUserSquareEvent, IUserSquareJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the sqaure draw event by the yser*/\r\nexport class UserSquareEvent extends UserEventBase implements IUserSquareEvent {\r\n    public type: Shapes = Shapes.SQUARE;    \r\n    shape: ISquare;\r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ISquare) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.render(context, this.capture_canvas_dimensions, current_canvas_dimensions);\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.shape.shift(from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): IUserSquareJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.exportToJson(),\r\n        }\r\n    }\r\n\r\n\r\n    /** Get the rectangle that encompasses the current swaure in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n        \r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.from_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.from_point, Math.min);\r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.to_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.to_point, Math.min);\r\n            \r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.from_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.from_point, Math.max);\r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.to_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.to_point, Math.max);\r\n        \r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { ISquare, ISquareJSON, Point, StrokeStyles } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\n/** Defines the class for square shape available to the user */\r\nexport class Square extends ShapeBase implements ISquare {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n    stroke_style: StrokeStyles;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string, stroke_style: StrokeStyles) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n        this.stroke_style = stroke_style;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n\r\n        context.setLineDash([this.getLineDashForStrokeStyle(this.stroke_style)]);\r\n        context.strokeStyle = this.border_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        );                     \r\n    }    \r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ISquareJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n            stroke_style: this.stroke_style,\r\n        }\r\n    }\r\n}\r\n\r\n","import { DEFAULT_POINT, ISquare, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserSquareEvent } from \"../../structures/events/square\";\r\nimport { Square } from \"../../structures/shapes/square\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class SquareCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private start_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ISquare | null = null;\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n     public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.start_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.start_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingSquare(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingSquare();\r\n        }\r\n    }\r\n\r\n\r\n    private continueCapturingSquare(point: Point) {\r\n        const square = new Square(this.start_coordinates, point, this.properties.border_color, this.properties.stroke_style);                \r\n\r\n        this.shape = square;\r\n        const renderer = Renderer.getInstance()\r\n        renderer.clearLayer();\r\n        renderer.renderShape(square);\r\n    }\r\n\r\n    private completeCapturingSquare(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape === null) return null;\r\n\r\n        const event = new UserSquareEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n        \r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);\r\n\r\n        this.shape = null;\r\n        this.start_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ICanvasUserEventProperties, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { ShapeCaptureManagerBase } from \"./shapes/base\";\r\nimport { PenCaptureManager } from \"./shapes/pen\";\r\nimport { SquareCaptureManager } from \"./shapes/square\";\r\n\r\nexport class CaptureManager extends ShapeCaptureManagerBase {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    /** Currently active manager capturing the shape */\r\n    active_manager: ShapeCaptureManagerBase | null = null;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape !== Shapes.NONE;\r\n    }\r\n    \r\n    /**\r\n    * Handle changes to the selected shape\r\n    * @param shape \r\n    */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.setActiveCaptureManager(shape);\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n\r\n    }\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n\r\n        if (this.active_manager !== null)\r\n            this.active_manager.onCanvasDrawingPropertiesChange(properties);\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_manager === null) return null;\r\n        return this.active_manager.onMouseMovement(point, is_mouse_down);\r\n    }\r\n\r\n    private setActiveCaptureManager(shape: Shapes){ \r\n        switch(shape) {\r\n            case (Shapes.PEN): {\r\n                this.active_manager = new PenCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            case (Shapes.SQUARE): {\r\n                this.active_manager = new SquareCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            default: {\r\n                this.active_manager = null;\r\n            }\r\n        }\r\n    }\r\n}","import { DEFAULT_POINT, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { Renderer } from \"../render\";\r\nimport { EventStore } from \"../store\";\r\n\r\nexport class SelectionManager {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    active_event: IUserEvent | null = null;\r\n    is_mouse_down: boolean = false;\r\n    last_coordinates: Point = DEFAULT_POINT;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape === Shapes.NONE;\r\n    }\r\n\r\n    /**\r\n     * Handle changes to the selected shape\r\n     * @param shape \r\n     */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.active_event = null;\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.isShiftingEvent(point)) {\r\n            const event = this.shiftEvent(point, is_mouse_down);\r\n            return event;\r\n        }\r\n        // Try selecting event\r\n        this.selectEvent(point, is_mouse_down);\r\n        return null;\r\n    }\r\n\r\n    private isShiftingEvent(point: Point): boolean {\r\n        return this.active_event !== null && this.is_mouse_down;\r\n    }    \r\n\r\n    private shiftEvent(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_event === null) return null;\r\n\r\n        const renderer = Renderer.getInstance()\r\n        if (is_mouse_down) {\r\n            // Conitnue shifting\r\n            this.active_event?.shift(this.last_coordinates, point);\r\n            renderer.shift(this.active_event);\r\n            this.last_coordinates = point;\r\n            \r\n            return null;\r\n        } else {\r\n            // Complete shifting\r\n            const event = this.active_event;\r\n            this.is_mouse_down = false;\r\n            this.last_coordinates = DEFAULT_POINT;\r\n            renderer.select(event);\r\n            return event;\r\n        }\r\n    }\r\n    private selectEvent(point: Point, is_mouse_down: boolean) {\r\n        if (is_mouse_down) {\r\n            const event = this.getEventAgainstPoint(point);\r\n            const renderer = Renderer.getInstance();\r\n\r\n            // Remove selection\r\n            if (event === null) {\r\n                this.reset();\r\n                renderer.pushObjectsOntoCanvas();\r\n            }\r\n            else if (this.active_event === null || !this.active_event.isEqual(event)) {                \r\n                this.active_event = event;\r\n                renderer.select(this.active_event);\r\n            }   \r\n\r\n            this.last_coordinates = point;\r\n            this.is_mouse_down = true;\r\n        } else {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    private getEventAgainstPoint(point: Point): IUserEvent | null {\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        let event: IUserEvent | null = null;        \r\n        for (let idx = events.length - 1; idx >= 0; idx-- ) {\r\n            if (events[idx].containsPoint(point)) {\r\n                event = events[idx];\r\n                break;\r\n            }\r\n        }\r\n        return event;\r\n    }\r\n}\r\n","import { IUserCanvasActionBase, IUserCanvasActionEventAdded, IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, UserCanvasActionType } from \"../interfaces\"\r\nimport { Manager } from \"./manager\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as IUserCanvasActionBase;\r\n\r\n    switch (data.type) {\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_USER: {\r\n            manager.initializeUser(data as IUserCanvasActionInitializeUser)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_MAIN_CANVAS: {\r\n            manager.initializeCanvas(data as IUserCanvasActionInitializeCanvas)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_TEMPORARY_LAYER: {\r\n            manager.initializeLayer(data as IUserCanvasActionInitializeLayer)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_DRAWING_PROPERTIES: {\r\n            manager.onCanvasDrawingPropertiesChange(data as IUserCanvasActionPropertiesChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_SELECTED_SHAPE: {\r\n            manager.onCanvasSelectedShapeChange(data as IUserCanvasActionShapeChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_MOUSE_POSITION: {\r\n            const event = manager.onMouseMovementOnCanvas(data as IUserCanvasActionMouseMovement)\r\n            if (event !== null) \r\n                postMessage({\r\n                    type: UserCanvasActionType.CANVAS_EVENTS_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as IUserCanvasActionEventAdded)\r\n\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_THEME_BASED_PROPERTIES: {\r\n            manager.onCanvasThemeBasedPropertiesChange(data as IUserCanvasActionThemeBasedPropertiesChange);\r\n            break;\r\n        }    \r\n    }\r\n}","import { IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, IUserEvent } from \"../interfaces\";\r\nimport { CaptureManager } from \"./managers/capture\";\r\nimport { SelectionManager } from \"./managers/selection\";\r\nimport { Renderer } from \"./render\";\r\nimport { EventStore, UserStore } from \"./store\";\r\n\r\nexport class Manager {\r\n\r\n    selection: SelectionManager = new SelectionManager();\r\n    capture: CaptureManager = new CaptureManager();\r\n\r\n    public initializeUser(data: IUserCanvasActionInitializeUser) {\r\n        const store = UserStore.getInstance();\r\n        store.setUserName(data.user_name);\r\n    }\r\n\r\n    public initializeCanvas(data: IUserCanvasActionInitializeCanvas) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeCanvas(\r\n            data.canvas,\r\n            data.dimensions,\r\n        );\r\n    }\r\n\r\n    public initializeLayer(data: IUserCanvasActionInitializeLayer) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeLayer(\r\n            data.canvas\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the drawing properties\r\n     * @param data \r\n     */\r\n    public onCanvasDrawingPropertiesChange(data: IUserCanvasActionPropertiesChange): void {\r\n        this.capture.onCanvasDrawingPropertiesChange(data.properties);\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the selected shape \r\n     * @param data \r\n     */\r\n    public onCanvasSelectedShapeChange(data: IUserCanvasActionShapeChange): void {\r\n        this.capture.onCanvasSelectedShapeChange(data.shape);\r\n        this.selection.onCanvasSelectedShapeChange(data.shape);\r\n        const renderer = Renderer.getInstance();\r\n        renderer.pushObjectsOntoCanvas();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse movement changes\r\n     * @param data \r\n     */\r\n    public onMouseMovementOnCanvas(data: IUserCanvasActionMouseMovement): IUserEvent| null {\r\n        const event_store = EventStore.getInstance();\r\n        if (this.capture.isEnabled()) {\r\n            const event =  this.capture.onMouseMovement(data.point, data.is_mouse_down);\r\n            \r\n            if (event !== null)\r\n                event_store.addEvent(event);\r\n\r\n            return event;\r\n        }\r\n\r\n        const event = this.selection.onMouseMovement(data.point, data.is_mouse_down);\r\n        if (event !== null)\r\n            event_store.updateEvent(event);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Handle changes in properties related to theme\r\n     * @param data \r\n     */\r\n    public onCanvasThemeBasedPropertiesChange(data: IUserCanvasActionThemeBasedPropertiesChange): void {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeSelectOutlineColor(\r\n            data.properties.select_outline_color,\r\n        )\r\n    }\r\n}"],"names":["DEFAULT_POINT","x","y","Shapes","UserCanvasActionType","StrokeStyles","DEFAULT_CANVAS_PROPERTIES","border_color","stroke_style","SOLID","ShapeCaptureManagerBase","constructor","properties","onCanvasDrawingPropertiesChange","this","onMouseMovement","point","is_mouse_down","Error","comparePoints","p1","p2","EventStore","events","getAllEvents","updateEvent","event","filter","evt","event_name","push","addEvent","getInstance","undefined","instance","UserStore","user_name","setUserName","getUserName","Renderer","canvas","layer","current_canvas_dimensions","currently_on_layer","shapes","select_outline_color","initializeCanvas","dimensions","context","getContext","initializeLayer","initializeSelectOutlineColor","color","renderEvent","render","renderShape","shape","pushObjectsOntoCanvas","forEach","clearLayer","select","clearCanvas","ev","isEqual","shift","renderAllEvents","clearContext","clearRect","normalizeCoordinates","coords","currentDimensions","captureDimensions","UserEventBase","capture_canvas_dimensions","type","NONE","getNewEventID","other","exportToJson","containsPoint","from_point","to_point","getAxisValue","axis","existing","candidate","func","result","characters","counter","charAt","Math","floor","random","UserPenEvent","super","PEN","line","getBoundingRect","fromCoords","toCoords","setLineDash","strokeStyle","strokeRect","map","min","max","ShapeBase","getLineDashForStrokeStyle","style","DOTTED","DASH","from_center","to_center","ratio","num","c","sqrt","pow","multiplier","Line","beginPath","moveTo","lineTo","closePath","stroke","PenCaptureManager","arguments","last_coordinates","continueCapturingLines","completeCapturingLines","renderer","user_store","length","UserSquareEvent","SQUARE","Square","SquareCaptureManager","start_coordinates","continueCapturingSquare","completeCapturingSquare","square","CaptureManager","active_manager","isEnabled","onCanvasSelectedShapeChange","setActiveCaptureManager","reset","SelectionManager","active_event","isShiftingEvent","shiftEvent","selectEvent","_this$active_event","getEventAgainstPoint","idx","manager","selection","capture","initializeUser","data","onMouseMovementOnCanvas","event_store","onCanvasThemeBasedPropertiesChange","onmessage","e","CANVAS_INITIALIZE_USER","CANVAS_INITIALIZE_MAIN_CANVAS","CANVAS_INITIALIZE_TEMPORARY_LAYER","CANVAS_CHANGE_DRAWING_PROPERTIES","CANVAS_CHANGE_SELECTED_SHAPE","CANVAS_CHANGE_MOUSE_POSITION","postMessage","CANVAS_EVENTS_ADDED","CANVAS_CHANGE_THEME_BASED_PROPERTIES"],"sourceRoot":""}