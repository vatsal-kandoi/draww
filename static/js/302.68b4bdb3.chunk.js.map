{"version":3,"file":"static/js/302.68b4bdb3.chunk.js","mappings":"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","sources":["interfaces/canvas/actions/user.ts","interfaces/canvas/shapes/base.ts","canvas/events/base.ts","canvas/events/pen.ts","canvas/events/manager.ts","canvas/utils/normalizeCoordinates.ts","canvas/structures/base.ts","canvas/structures/line.ts","canvas/structures/manager.ts","canvas/worker.ts","canvas/manager.ts"],"sourcesContent":["import { Point } from \"../base\";\r\nimport { EventJSONBase } from \"../events/base\";\r\nimport { ShapeTypes } from \"../shapes/base\";\r\n\r\nexport enum UserAction {\r\n    SHAPE_CHANGE = \"SHAPE_CHANGE\",\r\n    INIT_USER = \"INIT_USER\",\r\n    INIT_CANVAS = \"INIT_CANVAS\",\r\n    MOUSE_MOVE_EVENT = \"MOUSE_MOVE_EVENT\",\r\n    LOAD_EVENTS = \"LOAD_EVENTS\",\r\n    DELETE_ALL_EVENTS = \"DELETE_ALL_EVENTS\",\r\n    NEW_EVENT_ADDED = \"NEW_EVENT_ADDED\",\r\n}\r\n\r\nexport interface IShapeChange {\r\n    action: UserAction;\r\n    shape: ShapeTypes;\r\n}\r\n\r\nexport interface IInitUser { \r\n    action: UserAction;\r\n    user_name: string;\r\n}\r\n\r\nexport interface IInitCanvas {\r\n    action: UserAction;\r\n    canvas: OffscreenCanvas;\r\n    dimensions: Point,\r\n}\r\n\r\nexport interface IMouseMoveEvent {\r\n    action: UserAction;\r\n    point: Point;\r\n    isMouseDown: boolean;\r\n}\r\n\r\nexport interface INewEvent {\r\n    event: EventJSONBase;\r\n}","import { Point } from \"../base\";\r\n\r\nexport interface IShapeBase {\r\n    exportToJson: () => IShapeJSONBase;\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSONBase {}\r\n\r\nexport enum ShapeTypes {\r\n    NONE = \"NONE\",\r\n    LINE = \"LINE\",\r\n}","import { EventJSONBase, IEventBase, Point, ShapeTypes } from \"../../interfaces\";\r\n\r\nexport class EventBase implements IEventBase {\r\n    public type: ShapeTypes = ShapeTypes.NONE;    \r\n    public event_name: string;\r\n    public user_name: string;\r\n    public capture_canvas_dimensions: Point;\r\n    public current_canvas_dimensions: Point;\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string) {\r\n        this.current_canvas_dimensions = current_canvas_dimensions;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Validate if events match based on the name\r\n     * @param other IEventBase\r\n     * @returns boolean\r\n     */\r\n    public isEqual(other: IEventBase) {\r\n        return this.event_name === other.event_name;\r\n    }\r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    protected getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Render the event onto the canvas\r\n     * @param contextAPI Convext API for the canvas \r\n     */\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Export the event as a JSON object\r\n     */\r\n    public exportToJson(): EventJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n\r\n","import { IPenEvent, PenJSON, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { Line } from \"../structures/line\";\r\nimport { EventBase } from \"./base\";\r\n\r\nexport class PenEvent extends EventBase implements IPenEvent {\r\n    public type: ShapeTypes = ShapeTypes.LINE;    \r\n    shape: Line[];\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string, shape: Line[]) {\r\n        super(capture_canvas_dimensions, current_canvas_dimensions, user_name);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        this.shape.forEach(line => line.render(contextAPI, this.capture_canvas_dimensions, this.current_canvas_dimensions));\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public exportToJson(): PenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            current_canvas_dimensions: this.current_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n}\r\n\r\nexport default function capturePenEvent(\r\n    user_name: string,\r\n    shape: Line[],\r\n    dimensions: Point,\r\n): PenEvent {\r\n    const event = new PenEvent(dimensions, dimensions, user_name, shape);\r\n    return event;\r\n}","import { ShapeTypes } from \"../../interfaces\";\r\nimport { ShapeManager } from \"../structures/manager\";\r\nimport { EventBase } from \"./base\";\r\nimport capturePenEvent from \"./pen\";\r\n\r\nexport class EventManager {\r\n \r\n    user_name: string | null =  null;\r\n    events: EventBase[] = [];\r\n\r\n    public isInitialised(): boolean {\r\n        return this.user_name !== null;\r\n    }\r\n\r\n    public initialise(user_name: string) {\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    public createEvent(shapeManager: ShapeManager): EventBase | null {\r\n        if (this.user_name === null) return null;\r\n\r\n        switch (shapeManager.active_shape) {\r\n            case ShapeTypes.LINE: {\r\n                const event = capturePenEvent(this.user_name, shapeManager.shape, shapeManager.current_canvas_dimensions);\r\n                this.events.push(event);\r\n                return event;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { IShapeBase, IShapeJSONBase, Point } from \"../../interfaces\";\r\n\r\nexport class ShapeBase implements IShapeBase {\r\n    public exportToJson(): IShapeJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}","import { ILine, LineJSON, Point } from \"../../interfaces\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n\r\n    constructor(from_point: Point, to_point: Point) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public exportToJson(): LineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n        }\r\n    }\r\n}\r\n\r\nexport default function captureLine(\r\n    current_position: Point, \r\n    previous_position: Point, \r\n    context: OffscreenCanvasRenderingContext2D, \r\n    capture_canvas_dimensions: Point,\r\n    current_canvas_dimensions: Point,\r\n): LineJSON {\r\n    const line = new Line(previous_position, current_position);\r\n    line.render(context, capture_canvas_dimensions, current_canvas_dimensions);\r\n    return line;\r\n}","import { Point, ShapeTypes } from \"../../interfaces\";\r\nimport captureLine from \"./line\";\r\n\r\nconst DEFAULT_POINT: Point = { x: -1, y: -1 };\r\n\r\nexport class ShapeManager {\r\n    public active_shape: ShapeTypes = ShapeTypes.NONE;\r\n    public current_canvas_dimensions: Point = DEFAULT_POINT;\r\n    public shape: any = null;\r\n\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private offscreen_canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n\r\n    public reset(): void {\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        this.shape = null;\r\n    }\r\n\r\n    public isInitialised(): boolean {\r\n        return this.offscreen_canvas !== null;\r\n    }\r\n\r\n    public isInShapeCaptureMode(): boolean {\r\n        return this.active_shape !== ShapeTypes.NONE;\r\n    }\r\n\r\n    public canCaptureShape(): boolean {\r\n        return this.last_coordinates.x !== DEFAULT_POINT.x && this.last_coordinates.y !== DEFAULT_POINT.y;\r\n    }\r\n\r\n    public initialise(canvas: OffscreenCanvas, dimensions: Point) {\r\n        const context = canvas.getContext(\"2d\") \r\n        if (context=== null) return;\r\n        this.offscreen_canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }\r\n\r\n    public onSelectedShapeChange(selected_shape: ShapeTypes) {\r\n        this.active_shape = selected_shape;\r\n    }\r\n    \r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): boolean {\r\n        if (this.active_shape === ShapeTypes.NONE) return false;\r\n        if (!this.canCaptureShape()) {\r\n            if (!isMouseDown) return false;\r\n            this.last_coordinates = point;\r\n            this.is_mouse_down = true;\r\n            return false;\r\n        }\r\n        if (isMouseDown) {\r\n            this.captureShape(point);\r\n            this.last_coordinates = point;\r\n            return false;\r\n        } else {\r\n            if (this.shape === null) return false;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public captureShape(current_position: Point) {\r\n        if (this.offscreen_canvas === null) return;\r\n        switch (this.active_shape) {\r\n            case ShapeTypes.LINE: {\r\n                const line = captureLine(\r\n                    current_position, \r\n                    this.last_coordinates, \r\n                    this.offscreen_canvas, \r\n                    this.current_canvas_dimensions, \r\n                    this.current_canvas_dimensions\r\n                );\r\n                console.log(line)\r\n                if (this.shape === null)    \r\n                    this.shape = [];\r\n                this.shape.push(line);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}","import { IInitCanvas, IMouseMoveEvent, IInitUser, UserAction, IShapeChange, INewEvent } from \"../interfaces\";\r\nimport { Manager } from \"./manager\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as { action: UserAction, [key: string]: any };\r\n\r\n    switch (data.action) {\r\n        case UserAction.INIT_USER: {        \r\n            manager.onUserInit((data as IInitUser).user_name);\r\n            break;\r\n        } \r\n        case UserAction.INIT_CANVAS: {\r\n            manager.onCanvasInit(\r\n                (data as IInitCanvas).canvas, \r\n                (data as IInitCanvas).dimensions\r\n            );\r\n            break;\r\n        }\r\n        case UserAction.SHAPE_CHANGE: {\r\n            manager.onSelectedShapeChange((data as IShapeChange).shape);\r\n            break;\r\n        }\r\n        case UserAction.MOUSE_MOVE_EVENT: {\r\n            const event = manager.onMouseMoveEvent(\r\n                (data as IMouseMoveEvent).point,\r\n                (data as IMouseMoveEvent).isMouseDown\r\n            );\r\n            if (event !== null) {\r\n                postMessage({\r\n                    type: UserAction.NEW_EVENT_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as INewEvent);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n};","import {  Point, ShapeTypes } from \"../interfaces\";\r\nimport { EventBase } from \"./events/base\";\r\nimport { EventManager } from \"./events/manager\";\r\nimport { ShapeManager } from \"./structures/manager\";\r\n\r\n\r\nexport class Manager {\r\n\r\n    eventManager: EventManager = new EventManager();\r\n    shapeManager: ShapeManager = new ShapeManager();\r\n\r\n    public onUserInit(user_name: string): void {\r\n        this.eventManager.initialise(user_name);\r\n    }\r\n\r\n    public onCanvasInit(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        this.eventManager.initialise(\"Vatsal\");\r\n        this.shapeManager.initialise(canvas, dimensions);\r\n    }\r\n\r\n    public onSelectedShapeChange(selectedShape: ShapeTypes): void {\r\n        this.shapeManager.onSelectedShapeChange(selectedShape);\r\n        this.shapeManager.reset();\r\n    }\r\n\r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): null | EventBase {\r\n        if (!this.shapeManager.isInShapeCaptureMode()) return null;\r\n        const completed = this.shapeManager.onMouseMoveEvent(point, isMouseDown);\r\n        if (!completed) return null;        \r\n\r\n        const event = this.eventManager.createEvent(this.shapeManager);\r\n        if (event === null) return null;\r\n\r\n        this.shapeManager.reset();\r\n        return event;\r\n    }\r\n}"],"names":["UserAction","ShapeTypes","EventBase","constructor","capture_canvas_dimensions","current_canvas_dimensions","user_name","type","NONE","event_name","this","getNewEventID","isEqual","other","result","characters","counter","charAt","Math","floor","random","render","contextAPI","Error","select","exportToJson","PenEvent","shape","super","LINE","forEach","line","map","EventManager","events","isInitialised","initialise","createEvent","shapeManager","active_shape","event","dimensions","push","normalizeCoordinates","coords","currentDimensions","captureDimensions","x","y","ShapeBase","context","Line","from_point","to_point","fromCoords","toCoords","beginPath","moveTo","lineTo","closePath","stroke","DEFAULT_POINT","ShapeManager","last_coordinates","is_mouse_down","offscreen_canvas","reset","isInShapeCaptureMode","canCaptureShape","canvas","getContext","onSelectedShapeChange","selected_shape","onMouseMoveEvent","point","isMouseDown","captureShape","current_position","previous_position","captureLine","console","log","manager","eventManager","onUserInit","onCanvasInit","selectedShape","onmessage","e","data","action","INIT_USER","INIT_CANVAS","SHAPE_CHANGE","MOUSE_MOVE_EVENT","postMessage","NEW_EVENT_ADDED"],"sourceRoot":""}