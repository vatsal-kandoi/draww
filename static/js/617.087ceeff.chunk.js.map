{"version":3,"file":"static/js/617.087ceeff.chunk.js","mappings":"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","sources":["interfaces/structures/base/point.ts","interfaces/structures/shapes/base.ts","interfaces/actions/user/types.ts","interfaces/canvas/properties/theme.ts","interfaces/canvas/properties/user.ts","canvas/managers/shapes/base.ts","utils/canvas/comparePoints.ts","canvas/store.ts","canvas/render.ts","utils/canvas/normalizeCoordinates.ts","canvas/structures/events/base.ts","canvas/structures/events/pen.ts","canvas/structures/shapes/base.ts","utils/canvas/shift.ts","utils/numeric/abs.ts","canvas/structures/shapes/line.ts","canvas/managers/shapes/pen.ts","canvas/structures/events/square.ts","canvas/structures/shapes/square.ts","canvas/managers/shapes/square.ts","canvas/managers/capture.ts","canvas/managers/selection.ts","canvas/worker.ts","canvas/manager.ts"],"sourcesContent":["/** Defines the point / width & height of a interface */\r\nexport interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport const DEFAULT_POINT: Point = {\r\n    x: -1,\r\n    y: -1\r\n}","import { Point } from \"../base/point\";\r\n\r\n/** Shapes that can be selected by the user */\r\nexport enum Shapes {\r\n    NONE = \"NONE\",\r\n    PEN = \"PEN\",\r\n    SQUARE = \"SQUARE\",\r\n}\r\n\r\nexport interface IShape {\r\n    /** Export the shape to a JSON to be serialized & stored. Also can be downloaded by the user to be exported / sent to\r\n     * external people\r\n     */\r\n    exportToJson: () => IShapeJSON;\r\n    /**\r\n     * Render the shape onto the HTML canvas\r\n     * @param context HTML 2D context\r\n     * @param capture_canvas_dimensions Dimensions in which shape was captured \r\n     * @param current_canvas_dimensions Dimensions of the current canvas. The shape is rendered in a normalized fashion\r\n     */\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n    /**\r\n     * Shift the current shape to a new position based on the previous click & new click position ( drags )\r\n     * @param from_point Previous click position\r\n     * @param to_point New click position\r\n     */\r\n    shift: (from_point: Point, to_point: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSON { }\r\n\r\n","/** Defines interactions performed between canvas worker and the user */\r\nexport enum UserCanvasActionType {\r\n    CANVAS_INITIALIZE_USER = \"CANVAS_INITIALIZE_USER\",\r\n    CANVAS_INITIALIZE_MAIN_CANVAS = \"CANVAS_INITIALIZE_MAIN_CANVAS\",\r\n    CANVAS_INITIALIZE_TEMPORARY_LAYER = \"CANVAS_INITIALIZE_TEMPORARY_LAYER\",\r\n    \r\n    CANVAS_CHANGE_SELECTED_SHAPE = \"CANVAS_CHANGE_SELECTED_SHAPE\",\r\n    CANVAS_CHANGE_MOUSE_POSITION = \"CANVAS_CHANGE_MOUSE_POSITION\",\r\n    CANVAS_CHANGE_DRAWING_PROPERTIES = \"CANVAS_CHANGE_DRAWING_PROPERTIES\",\r\n    CANVAS_CHANGE_THEME_BASED_PROPERTIES = \"CANVAS_CHANGE_THEME_BASED_PROPERTIES\",\r\n\r\n    CANVAS_EVENTS_ADDED = \"CANVAS_EVENTS_ADDED\",\r\n    CANVAS_EVENTS_LOAD = \"CANVAS_EVENTS_LOAD\",\r\n    CANVAS_EVENTS_DELETE_ALL = \"CANVAS_EVENTS_DELETE_ALL\",\r\n}\r\n","\r\nexport interface ICanvasThemeBasedProperties {\r\n    /** OUtline color for the selection border */\r\n    select_outline_color: string;\r\n}\r\n\r\nexport const DEFAULT_THEME_BASED_PROPERTIES: ICanvasThemeBasedProperties = {\r\n    select_outline_color: \"#000\",\r\n}","\r\nexport interface ICanvasUserEventProperties {\r\n    /** Color assigned to the border strokes */\r\n    border_color: string;\r\n}\r\nexport const DEFAULT_CANVAS_PROPERTIES: ICanvasUserEventProperties = {\r\n    border_color: \"#000\",\r\n}","import { DEFAULT_CANVAS_PROPERTIES, ICanvasUserEventProperties, IUserEvent, Point } from \"../../../interfaces\";\r\n\r\nexport class ShapeCaptureManagerBase {\r\n    properties: ICanvasUserEventProperties = DEFAULT_CANVAS_PROPERTIES;\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        throw new Error(\"Not implemented\")\r\n    }\r\n\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport default function comparePoints(p1: Point, p2: Point) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}","import { IUserEvent } from \"../interfaces\";\r\n\r\nexport class EventStore {\r\n    private static instance: EventStore;\r\n\r\n    private events: IUserEvent[] = [];\r\n\r\n    /**\r\n     * Get all user events currently in store\r\n     * @returns All user events\r\n     */\r\n    public getAllEvents(): IUserEvent[] {\r\n        return this.events;\r\n    }\r\n\r\n    /**\r\n     * Update the event in the store\r\n     * @param event Event to be updated\r\n     */\r\n    public updateEvent(event: IUserEvent) {\r\n        this.events = this.events.filter((evt) => evt.event_name !== event.event_name);\r\n        this.events.push(event);        \r\n    }\r\n\r\n    /**\r\n     * Add the user event to the store\r\n     * @param event Event to be added\r\n     */\r\n    public addEvent(event: IUserEvent) {\r\n        this.events.push(event);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the event store\r\n     * @returns Event store instance\r\n     */\r\n    public static getInstance(): EventStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new EventStore();\r\n\r\n        return this.instance;\r\n    }\r\n}\r\n\r\nexport class UserStore {\r\n    private static instance: UserStore;\r\n\r\n    private user_name: string = \"\";\r\n\r\n    /**\r\n     * Set the user name\r\n     * @param user_name user name\r\n     */\r\n    public setUserName(user_name: string): void {\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the user name\r\n     * @returns User name\r\n     */\r\n    public getUserName(): string {\r\n        return this.user_name;\r\n    }\r\n\r\n    /**\r\n     * Get the store\r\n     * @returns User store instance\r\n     */\r\n    public static getInstance(): UserStore {\r\n        if (this.instance === undefined)\r\n            this.instance = new UserStore();\r\n\r\n        return this.instance;\r\n    }\r\n}","import { DEFAULT_POINT, IShape, IUserEvent, Point } from \"../interfaces\";\r\nimport { ShapeBase } from \"./structures/shapes/base\";\r\nimport { EventStore } from \"./store\";\r\n\r\ninterface OnLayerObjects {\r\n    /** Events on layer & not on canvas */\r\n    events: IUserEvent[]; \r\n    /** Shapes on layer & not on canvas */\r\n    shapes: IShape[];\r\n}\r\n\r\nexport class Renderer {\r\n    private static instance: Renderer;\r\n\r\n    /** HTML offscreen canvas */\r\n    canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Temporary HTML offscreen layer */\r\n    layer: OffscreenCanvasRenderingContext2D | null = null;\r\n    /** Canvas dimensions */\r\n    current_canvas_dimensions: Point = DEFAULT_POINT;\r\n    /** Events & shapes on layer and not on canvas */\r\n    currently_on_layer: OnLayerObjects = {\r\n        events: [],\r\n        shapes: [],\r\n    };\r\n    /** Outline color for the selection border box */\r\n    select_outline_color: string = \"#000\"\r\n\r\n\r\n    /**\r\n     * Initialise the canvas and store the context\r\n     * @param canvas HTML offscreen canvas\r\n     * @param dimensions canvas dimensions\r\n     */\r\n    public initializeCanvas(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }\r\n\r\n    /**\r\n     * Initialise the canvas and store the context for the temporary layer\r\n     * @param canvas HTML offscreen canvas for the layer\r\n     */\r\n    public initializeLayer(canvas: OffscreenCanvas) {\r\n        const context = canvas.getContext(\"2d\");\r\n\r\n        if (context === null)\r\n            return;\r\n\r\n        this.layer = context as OffscreenCanvasRenderingContext2D;\r\n    }\r\n\r\n    /**\r\n     * Initialize the outline color\r\n     * @param color Color to be selected\r\n     */\r\n    public initializeSelectOutlineColor(color: string) {\r\n        this.select_outline_color = color;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Get the renderer instance\r\n     * @returns Renderer instance\r\n     */\r\n    public static getInstance(): Renderer {\r\n        if (this.instance === undefined)\r\n            this.instance = new Renderer();\r\n\r\n        return this.instance;\r\n    }\r\n\r\n    /**\r\n     * Render the event on the main canvas\r\n     * @param event User event\r\n     */\r\n    public renderEvent(event: IUserEvent): void {\r\n        if (this.canvas === null) return;\r\n        event.render(this.canvas, this.current_canvas_dimensions);\r\n    }\r\n\r\n    /**\r\n     * Render the shape on the temporary layer\r\n     * @param shape Shape\r\n     */\r\n    public renderShape(shape: ShapeBase): void {\r\n        if (this.layer === null) return;\r\n        shape.render(this.layer, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        this.currently_on_layer.shapes.push(shape);\r\n    }\r\n\r\n    /**\r\n     * Push the objects in the temporary layer onto the canvas\r\n     */\r\n    public pushObjectsOntoCanvas(): void {\r\n        this.currently_on_layer.events.forEach((event) => {\r\n            if(this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n        this.currently_on_layer.shapes.forEach((shape) => {\r\n            if(this.canvas === null) return;\r\n            shape.render(this.canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n        })\r\n        this.clearLayer();\r\n    }\r\n\r\n    /**\r\n     * Select the event by rendering it on the temporary layer and render remaining events on the main\r\n     * canvas\r\n     * @param event User event\r\n     */\r\n    public select(event: IUserEvent) {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((ev: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            if (!ev.isEqual(event))\r\n                ev.render(this.canvas, this.current_canvas_dimensions);\r\n        })\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** Shift the event & render the shifted event on the layer */\r\n    public shift(event: IUserEvent) {\r\n        this.clearLayer();\r\n\r\n        if (this.layer === null) return;\r\n        event.select(this.layer, this.current_canvas_dimensions, this.select_outline_color);\r\n        this.currently_on_layer.events.push(event);\r\n    }\r\n\r\n    /** \r\n     * Render all the events in the store\r\n     */\r\n    public renderAllEvents(): void {\r\n        this.clearCanvas();\r\n        this.clearLayer();\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        \r\n        events.forEach((event: IUserEvent) => {\r\n            if (this.canvas === null) return;\r\n            event.render(this.canvas, this.current_canvas_dimensions);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events\r\n    */\r\n    public clearCanvas() {\r\n        if (this.canvas === null) return;\r\n        this.clearContext(this.canvas);\r\n    }\r\n\r\n    /**\r\n     * Clear the main canvas of all events & shapes\r\n    */\r\n    public clearLayer() {   \r\n        if (this.layer === null) return;\r\n        this.clearContext(this.layer);\r\n        this.currently_on_layer = {events: [], shapes: []};\r\n    }\r\n\r\n    /**\r\n     * Clear the context of any events & shapes\r\n     * @param context HTML canvas offscreen 2D context\r\n     */\r\n    private clearContext(context: OffscreenCanvasRenderingContext2D) {\r\n        context.clearRect(\r\n            0,\r\n            0,\r\n            this.current_canvas_dimensions.x,\r\n            this.current_canvas_dimensions.y\r\n        )\r\n    }\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { IShape, IUserEvent, IUserEventJSON, Point, Shapes } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all events generated by the user */\r\nexport class UserEventBase implements IUserEvent {\r\n    \r\n    type: Shapes = Shapes.NONE;\r\n    event_name: string;\r\n    user_name: string;\r\n    shape: IShape | IShape[];\r\n    capture_canvas_dimensions: Point;\r\n    \r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: IShape | IShape[]) {\r\n        this.shape = shape;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    public isEqual(other: IUserEvent) {\r\n        return this.event_name === other.event_name;\r\n    }    \r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public exportToJson(): IUserEventJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public containsPoint (point: Point): boolean {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    \r\n    public shift (from_point: Point, to_point: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the axis value based on existing & candidate points based on the Math max or min function\r\n     * @param axis Axis x or y\r\n     * @param existing Existing point\r\n     * @param candidate POint to be considered\r\n     * @param func Max or min function\r\n     * @returns new axis value\r\n     */\r\n    protected getAxisValue(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: typeof Math.min | typeof Math.max ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }    \r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    private getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n","import { ILine, IUserPenEvent, IUserPenJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the freeform pen draw event by the yser*/\r\nexport class UserPenEvent extends UserEventBase implements IUserPenEvent {\r\n    public type: Shapes = Shapes.PEN;    \r\n    shape: ILine[];    \r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ILine[]) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n    \r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.forEach(line => line.render(context, this.capture_canvas_dimensions, current_canvas_dimensions));\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.forEach((line) => {\r\n            line.shift(from_point, to_point);\r\n        })\r\n    }\r\n\r\n    public exportToJson(): IUserPenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n\r\n    /** Get the rectangle that encompasses the current set of lines in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n\r\n        this.shape.forEach((line) => {\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.from_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.from_point, Math.min);\r\n            from_point.x = this.getAxisValue(\"x\", from_point, line.to_point, Math.min);\r\n            from_point.y = this.getAxisValue(\"y\", from_point, line.to_point, Math.min);\r\n            \r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.from_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.from_point, Math.max);\r\n            to_point.x = this.getAxisValue(\"x\", to_point, line.to_point, Math.max);\r\n            to_point.y = this.getAxisValue(\"y\", to_point, line.to_point, Math.max);\r\n        });\r\n\r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { IShape, IShapeJSON, Point } from \"../../../interfaces\";\r\n\r\n/** Defines the base class for all shapes available to the user */\r\nexport class ShapeBase implements IShape {\r\n\r\n    public exportToJson(): IShapeJSON {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }    \r\n}","import { Point } from \"../../interfaces\";\r\nimport abs from \"../numeric/abs\";\r\n\r\nexport function shift(point: Point, from_center: Point, to_center: Point): Point {\r\n    const ratio = abs((from_center.y - point.y) / (from_center.x - point.x));\r\n    const distance = Math.sqrt(Math.pow( from_center.y - point.y, 2) +  Math.pow(from_center.x - point.x, 2))\r\n    const c = distance / Math.sqrt( ( Math.pow(ratio, 2) + 1 ))\r\n\r\n    const multiplier = {\r\n        x: point.x < from_center.x ? -1 : 1,\r\n        y: point.y < from_center.y ? -1 : 1,\r\n    }\r\n\r\n    return {\r\n        x: to_center.x + multiplier.x * c,\r\n        y: to_center.y + multiplier.y * ratio * c\r\n    }\r\n}","export default function abs(num: number): number {\r\n    if (num < 0)\r\n        return -1 * num;\r\n    return num;\r\n}","import { ShapeBase } from \"./base\";\r\nimport { ILine, ILineJSON, Point } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\n\r\n/** Defines the class for line shape available to the user */\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n        context.strokeStyle = this.border_color;\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ILineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}","import { DEFAULT_POINT, ILine, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserPenEvent } from \"../../structures/events/pen\";\r\nimport { Line } from \"../../structures/shapes/line\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class PenCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ILine[] = [];\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.last_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.last_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingLines(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingLines();\r\n        }\r\n    }\r\n    \r\n    private continueCapturingLines(point: Point) {\r\n        const line = new Line(this.last_coordinates, point, this.properties.border_color);                \r\n\r\n        this.shape.push(line);\r\n\r\n        const renderer = Renderer.getInstance()\r\n        renderer.renderShape(line);\r\n\r\n        this.last_coordinates = point;\r\n    }\r\n\r\n    private completeCapturingLines(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape.length === 0) return null;\r\n\r\n        const event = new UserPenEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n\r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);        \r\n        \r\n        this.shape = [];\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ISquare, IUserSquareEvent, IUserSquareJSON, Point, Shapes } from \"../../../interfaces\";\r\nimport { normalizeCoordinates } from \"../../../utils\";\r\nimport { UserEventBase } from \"./base\";\r\n\r\n/** Defines the class for the sqaure draw event by the yser*/\r\nexport class UserSquareEvent extends UserEventBase implements IUserSquareEvent {\r\n    public type: Shapes = Shapes.SQUARE;    \r\n    shape: ISquare;\r\n\r\n    constructor(capture_canvas_dimensions: Point, user_name: string, shape: ISquare) {\r\n        super(capture_canvas_dimensions, user_name, shape);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {\r\n        this.shape.render(context, this.capture_canvas_dimensions, current_canvas_dimensions);\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(context, current_canvas_dimensions);\r\n\r\n        context.setLineDash([6]);\r\n        context.strokeStyle = select_outline_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        context.setLineDash([0]);\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.shape.shift(from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): IUserSquareJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            shape: this.shape.exportToJson(),\r\n        }\r\n    }\r\n\r\n\r\n    /** Get the rectangle that encompasses the current swaure in the event */\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n        \r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.from_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.from_point, Math.min);\r\n        from_point.x = this.getAxisValue(\"x\", from_point, this.shape.to_point, Math.min);\r\n        from_point.y = this.getAxisValue(\"y\", from_point, this.shape.to_point, Math.min);\r\n            \r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.from_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.from_point, Math.max);\r\n        to_point.x = this.getAxisValue(\"x\", to_point, this.shape.to_point, Math.max);\r\n        to_point.y = this.getAxisValue(\"y\", to_point, this.shape.to_point, Math.max);\r\n        \r\n        return { from_point, to_point };\r\n    }\r\n}\r\n","import { ISquare, ISquareJSON, Point } from \"../../../interfaces\";\r\nimport { normalizeCoordinates, shift } from \"../../../utils\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\n/** Defines the class for square shape available to the user */\r\nexport class Square extends ShapeBase implements ISquare {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        context.strokeStyle = this.border_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        );                     \r\n    }    \r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): ISquareJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}\r\n\r\n","import { DEFAULT_POINT, ISquare, IUserEvent, Point } from \"../../../interfaces\";\r\nimport comparePoints from \"../../../utils/canvas/comparePoints\";\r\nimport { Renderer } from \"../../render\";\r\nimport { UserStore } from \"../../store\";\r\nimport { UserSquareEvent } from \"../../structures/events/square\";\r\nimport { Square } from \"../../structures/shapes/square\";\r\nimport { ShapeCaptureManagerBase } from \"./base\";\r\n\r\nexport class SquareCaptureManager extends ShapeCaptureManagerBase{\r\n\r\n    private start_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private shape: ISquare | null = null;\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n     public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        /** When the user has just started capturing and cannot draw till now */\r\n        if (comparePoints(this.start_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (is_mouse_down) {\r\n                this.start_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Continue capturing line\r\n        if (is_mouse_down) {\r\n            this.continueCapturingSquare(point);\r\n            return null;\r\n        } else {\r\n            return this.completeCapturingSquare();\r\n        }\r\n    }\r\n\r\n\r\n    private continueCapturingSquare(point: Point) {\r\n        const square = new Square(this.start_coordinates, point, this.properties.border_color);                \r\n\r\n        this.shape = square;\r\n        const renderer = Renderer.getInstance()\r\n        renderer.clearLayer();\r\n        renderer.renderShape(square);\r\n    }\r\n\r\n    private completeCapturingSquare(): IUserEvent | null {\r\n        const renderer = Renderer.getInstance();\r\n        const user_store = UserStore.getInstance();\r\n\r\n        if (this.shape === null) return null;\r\n\r\n        const event = new UserSquareEvent(\r\n            renderer.current_canvas_dimensions,\r\n            user_store.getUserName(),\r\n            this.shape,            \r\n        );\r\n        \r\n        renderer.clearLayer();\r\n        renderer.renderEvent(event);\r\n\r\n        this.shape = null;\r\n        this.start_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return event;\r\n    }\r\n}","import { ICanvasUserEventProperties, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { ShapeCaptureManagerBase } from \"./shapes/base\";\r\nimport { PenCaptureManager } from \"./shapes/pen\";\r\nimport { SquareCaptureManager } from \"./shapes/square\";\r\n\r\nexport class CaptureManager extends ShapeCaptureManagerBase {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    /** Currently active manager capturing the shape */\r\n    active_manager: ShapeCaptureManagerBase | null = null;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape !== Shapes.NONE;\r\n    }\r\n    \r\n    /**\r\n    * Handle changes to the selected shape\r\n    * @param shape \r\n    */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.setActiveCaptureManager(shape);\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n\r\n    }\r\n\r\n    /** Handle changes made to the drawing properties */\r\n    public onCanvasDrawingPropertiesChange(properties: ICanvasUserEventProperties) {\r\n        this.properties = properties;\r\n\r\n        if (this.active_manager !== null)\r\n            this.active_manager.onCanvasDrawingPropertiesChange(properties);\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_manager === null) return null;\r\n        return this.active_manager.onMouseMovement(point, is_mouse_down);\r\n    }\r\n\r\n    private setActiveCaptureManager(shape: Shapes){ \r\n        switch(shape) {\r\n            case (Shapes.PEN): {\r\n                this.active_manager = new PenCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            case (Shapes.SQUARE): {\r\n                this.active_manager = new SquareCaptureManager();\r\n                this.active_manager.onCanvasDrawingPropertiesChange(this.properties);\r\n\r\n                break;\r\n            }\r\n            default: {\r\n                this.active_manager = null;\r\n            }\r\n        }\r\n    }\r\n}","import { DEFAULT_POINT, IUserEvent, Point, Shapes } from \"../../interfaces\";\r\nimport { Renderer } from \"../render\";\r\nimport { EventStore } from \"../store\";\r\n\r\nexport class SelectionManager {\r\n\r\n    shape: Shapes = Shapes.NONE;\r\n    active_event: IUserEvent | null = null;\r\n    is_mouse_down: boolean = false;\r\n    last_coordinates: Point = DEFAULT_POINT;\r\n\r\n    /** Change whether the selection is enabled or not based on shape type */\r\n    public isEnabled(): boolean {\r\n        return this.shape === Shapes.NONE;\r\n    }\r\n\r\n    /**\r\n     * Handle changes to the selected shape\r\n     * @param shape \r\n     */\r\n    public onCanvasSelectedShapeChange(shape: Shapes): void {\r\n        this.shape = shape;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.active_event = null;\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n    }\r\n\r\n    /**\r\n     * Handle movements of mouse, and render accordingly\r\n     * @param point Cursor on point\r\n     * @param is_mouse_down Whether mouse is clicked\r\n     */\r\n    public onMouseMovement(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.isShiftingEvent(point)) {\r\n            const event = this.shiftEvent(point, is_mouse_down);\r\n            return event;\r\n        }\r\n        // Try selecting event\r\n        this.selectEvent(point, is_mouse_down);\r\n        return null;\r\n    }\r\n\r\n    private isShiftingEvent(point: Point): boolean {\r\n        return this.active_event !== null && this.is_mouse_down;\r\n    }    \r\n\r\n    private shiftEvent(point: Point, is_mouse_down: boolean): IUserEvent | null {\r\n        if (this.active_event === null) return null;\r\n\r\n        const renderer = Renderer.getInstance()\r\n        if (is_mouse_down) {\r\n            // Conitnue shifting\r\n            console.log(point, is_mouse_down);\r\n            this.active_event?.shift(this.last_coordinates, point);\r\n            console.log(this.active_event)\r\n            renderer.shift(this.active_event);\r\n            this.last_coordinates = point;\r\n            \r\n            return null;\r\n        } else {\r\n            // Complete shifting\r\n            const event = this.active_event;\r\n            this.is_mouse_down = false;\r\n            this.last_coordinates = DEFAULT_POINT;\r\n            renderer.select(event);\r\n            return event;\r\n        }\r\n    }\r\n    private selectEvent(point: Point, is_mouse_down: boolean) {\r\n        if (is_mouse_down) {\r\n            const event = this.getEventAgainstPoint(point);\r\n            const renderer = Renderer.getInstance();\r\n\r\n            // Remove selection\r\n            if (event === null) {\r\n                this.active_event = null;\r\n                this.last_coordinates = DEFAULT_POINT;\r\n                this.is_mouse_down = false;\r\n                renderer.pushObjectsOntoCanvas();\r\n            }\r\n            else if (this.active_event === null || !this.active_event.isEqual(event)) {                \r\n                this.active_event = event;\r\n                renderer.select(this.active_event);\r\n            }   \r\n\r\n            this.last_coordinates = point;\r\n            this.is_mouse_down = true;\r\n        } else {\r\n            this.active_event = null;\r\n            this.last_coordinates = DEFAULT_POINT;\r\n            this.is_mouse_down = false;\r\n        }\r\n    }\r\n\r\n    private getEventAgainstPoint(point: Point): IUserEvent | null {\r\n        const events = EventStore.getInstance().getAllEvents();\r\n        console.log(events);\r\n        let event: IUserEvent | null = null;        \r\n        for (let idx = events.length - 1; idx >= 0; idx-- ) {\r\n            if (events[idx].containsPoint(point)) {\r\n                event = events[idx];\r\n                break;\r\n            }\r\n        }\r\n        return event;\r\n    }\r\n}\r\n","import { IUserCanvasActionBase, IUserCanvasActionEventAdded, IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, UserCanvasActionType } from \"../interfaces\"\r\nimport { Manager } from \"./manager\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as IUserCanvasActionBase;\r\n\r\n    switch (data.type) {\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_USER: {\r\n            manager.initializeUser(data as IUserCanvasActionInitializeUser)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_MAIN_CANVAS: {\r\n            manager.initializeCanvas(data as IUserCanvasActionInitializeCanvas)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_INITIALIZE_TEMPORARY_LAYER: {\r\n            manager.initializeLayer(data as IUserCanvasActionInitializeLayer)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_DRAWING_PROPERTIES: {\r\n            manager.onCanvasDrawingPropertiesChange(data as IUserCanvasActionPropertiesChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_SELECTED_SHAPE: {\r\n            manager.onCanvasSelectedShapeChange(data as IUserCanvasActionShapeChange)\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_MOUSE_POSITION: {\r\n            const event = manager.onMouseMovementOnCanvas(data as IUserCanvasActionMouseMovement)\r\n            if (event !== null) \r\n                postMessage({\r\n                    type: UserCanvasActionType.CANVAS_EVENTS_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as IUserCanvasActionEventAdded)\r\n\r\n            break;\r\n        }\r\n        case UserCanvasActionType.CANVAS_CHANGE_THEME_BASED_PROPERTIES: {\r\n            manager.onCanvasThemeBasedPropertiesChange(data as IUserCanvasActionThemeBasedPropertiesChange);\r\n            break;\r\n        }    \r\n    }\r\n}","import { IUserCanvasActionInitializeCanvas, IUserCanvasActionInitializeLayer, IUserCanvasActionInitializeUser, IUserCanvasActionMouseMovement, IUserCanvasActionPropertiesChange, IUserCanvasActionShapeChange, IUserCanvasActionThemeBasedPropertiesChange, IUserEvent } from \"../interfaces\";\r\nimport { CaptureManager } from \"./managers/capture\";\r\nimport { SelectionManager } from \"./managers/selection\";\r\nimport { Renderer } from \"./render\";\r\nimport { EventStore, UserStore } from \"./store\";\r\n\r\nexport class Manager {\r\n\r\n    selection: SelectionManager = new SelectionManager();\r\n    capture: CaptureManager = new CaptureManager();\r\n\r\n    public initializeUser(data: IUserCanvasActionInitializeUser) {\r\n        const store = UserStore.getInstance();\r\n        store.setUserName(data.user_name);\r\n    }\r\n\r\n    public initializeCanvas(data: IUserCanvasActionInitializeCanvas) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeCanvas(\r\n            data.canvas,\r\n            data.dimensions,\r\n        );\r\n    }\r\n\r\n    public initializeLayer(data: IUserCanvasActionInitializeLayer) {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeLayer(\r\n            data.canvas\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the drawing properties\r\n     * @param data \r\n     */\r\n    public onCanvasDrawingPropertiesChange(data: IUserCanvasActionPropertiesChange): void {\r\n        this.capture.onCanvasDrawingPropertiesChange(data.properties);\r\n    }\r\n\r\n    /**\r\n     * Handle changes made to the selected shape \r\n     * @param data \r\n     */\r\n    public onCanvasSelectedShapeChange(data: IUserCanvasActionShapeChange): void {\r\n        this.capture.onCanvasSelectedShapeChange(data.shape);\r\n        this.selection.onCanvasSelectedShapeChange(data.shape);\r\n        const renderer = Renderer.getInstance();\r\n        renderer.pushObjectsOntoCanvas();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse movement changes\r\n     * @param data \r\n     */\r\n    public onMouseMovementOnCanvas(data: IUserCanvasActionMouseMovement): IUserEvent| null {\r\n        const event_store = EventStore.getInstance();\r\n        if (this.capture.isEnabled()) {\r\n            const event =  this.capture.onMouseMovement(data.point, data.is_mouse_down);\r\n            \r\n            if (event !== null)\r\n                event_store.addEvent(event);\r\n\r\n            return event;\r\n        }\r\n\r\n        const event = this.selection.onMouseMovement(data.point, data.is_mouse_down);\r\n        if (event !== null)\r\n            event_store.updateEvent(event);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Handle changes in properties related to theme\r\n     * @param data \r\n     */\r\n    public onCanvasThemeBasedPropertiesChange(data: IUserCanvasActionThemeBasedPropertiesChange): void {\r\n        const renderer = Renderer.getInstance();\r\n        renderer.initializeSelectOutlineColor(\r\n            data.properties.select_outline_color,\r\n        )\r\n    }\r\n}"],"names":["DEFAULT_POINT","x","y","Shapes","UserCanvasActionType","DEFAULT_CANVAS_PROPERTIES","border_color","ShapeCaptureManagerBase","constructor","properties","onCanvasDrawingPropertiesChange","this","onMouseMovement","point","is_mouse_down","Error","comparePoints","p1","p2","EventStore","events","getAllEvents","updateEvent","event","filter","evt","event_name","push","addEvent","getInstance","undefined","instance","UserStore","user_name","setUserName","getUserName","Renderer","canvas","layer","current_canvas_dimensions","currently_on_layer","shapes","select_outline_color","initializeCanvas","dimensions","context","getContext","initializeLayer","initializeSelectOutlineColor","color","renderEvent","render","renderShape","shape","pushObjectsOntoCanvas","forEach","clearLayer","select","clearCanvas","ev","isEqual","shift","renderAllEvents","clearContext","clearRect","normalizeCoordinates","coords","currentDimensions","captureDimensions","UserEventBase","capture_canvas_dimensions","type","NONE","getNewEventID","other","exportToJson","containsPoint","from_point","to_point","getAxisValue","axis","existing","candidate","func","result","characters","counter","charAt","Math","floor","random","UserPenEvent","super","PEN","line","getBoundingRect","fromCoords","toCoords","setLineDash","strokeStyle","strokeRect","map","min","max","ShapeBase","from_center","to_center","ratio","num","c","sqrt","pow","multiplier","Line","beginPath","moveTo","lineTo","closePath","stroke","PenCaptureManager","arguments","last_coordinates","continueCapturingLines","completeCapturingLines","renderer","user_store","length","UserSquareEvent","SQUARE","Square","SquareCaptureManager","start_coordinates","continueCapturingSquare","completeCapturingSquare","square","CaptureManager","active_manager","isEnabled","onCanvasSelectedShapeChange","setActiveCaptureManager","reset","SelectionManager","active_event","isShiftingEvent","shiftEvent","selectEvent","_this$active_event","console","log","getEventAgainstPoint","idx","manager","selection","capture","initializeUser","data","onMouseMovementOnCanvas","event_store","onCanvasThemeBasedPropertiesChange","onmessage","e","CANVAS_INITIALIZE_USER","CANVAS_INITIALIZE_MAIN_CANVAS","CANVAS_INITIALIZE_TEMPORARY_LAYER","CANVAS_CHANGE_DRAWING_PROPERTIES","CANVAS_CHANGE_SELECTED_SHAPE","CANVAS_CHANGE_MOUSE_POSITION","postMessage","CANVAS_EVENTS_ADDED","CANVAS_CHANGE_THEME_BASED_PROPERTIES"],"sourceRoot":""}