{"version":3,"file":"static/js/519.f101c32e.chunk.js","mappings":"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","sources":["interfaces/canvas/actions/user.ts","interfaces/canvas/shapes/base.ts","canvas/utils/normalizeCoordinates.ts","canvas/events/base.ts","canvas/events/pen.ts","canvas/events/square.ts","canvas/managers/events.ts","canvas/managers/render.ts","canvas/managers/selection.ts","canvas/utils/shift.ts","canvas/utils/abs.ts","canvas/structures/base.ts","canvas/structures/line.ts","canvas/structures/square.ts","canvas/utils/comparePoints.ts","canvas/managers/shape.ts","canvas/worker.ts","canvas/managers/index.ts"],"sourcesContent":["import { Point } from \"../base\";\r\nimport { EventJSONBase } from \"../events/base\";\r\nimport { ShapeTypes } from \"../shapes/base\";\r\n\r\nexport enum UserAction {\r\n    SHAPE_CHANGE = \"SHAPE_CHANGE\",\r\n    INIT_USER = \"INIT_USER\",\r\n    INIT_CANVAS = \"INIT_CANVAS\",\r\n    INIT_TEMPORARY_CANVAS = \"INIT_TEMPORARY_CANVAS\",\r\n    MOUSE_MOVE_EVENT = \"MOUSE_MOVE_EVENT\",\r\n    LOAD_EVENTS = \"LOAD_EVENTS\",\r\n    DELETE_ALL_EVENTS = \"DELETE_ALL_EVENTS\",\r\n    NEW_EVENT_ADDED = \"NEW_EVENT_ADDED\",\r\n    PROPERTIES_CHANGE = \"PROPERTIES_CHANGE\",\r\n    THEME_CHANGE = \"THEME_CHANGE\",\r\n}\r\n\r\nexport interface IProperties {\r\n    borderColor: string;\r\n}\r\n\r\nexport interface IThemeProperties {\r\n    select_color: string;\r\n}\r\n\r\nexport interface IThemeChange extends IThemeProperties {\r\n    action: UserAction;\r\n}\r\n\r\nexport interface IPropertiesChange extends IProperties {\r\n    action: UserAction;\r\n}\r\n\r\nexport interface IShapeChange {\r\n    action: UserAction;\r\n    shape: ShapeTypes;\r\n}\r\n\r\nexport interface IInitUser { \r\n    action: UserAction;\r\n    user_name: string;\r\n}\r\n\r\nexport interface IInitCanvas {\r\n    action: UserAction;\r\n    canvas: OffscreenCanvas;\r\n    dimensions: Point,\r\n}\r\n\r\nexport interface IInitTemporaryCanvas {\r\n    action: UserAction;\r\n    canvas: OffscreenCanvas;\r\n    dimensions: Point,\r\n}\r\n\r\nexport interface IMouseMoveEvent {\r\n    action: UserAction;\r\n    point: Point;\r\n    isMouseDown: boolean;\r\n}\r\n\r\nexport interface INewEvent {\r\n    event: EventJSONBase;\r\n}","import { Point } from \"../base\";\r\n\r\nexport interface IShapeBase {\r\n    exportToJson: () => IShapeJSONBase;\r\n    render: (context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point) => void;\r\n    shift: (from_point: Point, to_point: Point) => void;\r\n}\r\n\r\nexport interface IShapeJSONBase {\r\n}\r\n\r\nexport enum ShapeTypes {\r\n    NONE = \"NONE\",\r\n    LINE = \"LINE\",\r\n    SQUARE = \"SQUARE\",\r\n}","import { Point } from \"../../interfaces\";\r\n\r\nexport function normalizeCoordinates(coords: Point, currentDimensions: Point, captureDimensions: Point): Point {\r\n    if (currentDimensions === captureDimensions) return coords;    \r\n\r\n    return {\r\n        x: ( coords.x / captureDimensions.x ) * currentDimensions.x,\r\n        y: ( coords.y / captureDimensions.y ) * currentDimensions.y\r\n    }\r\n}\r\n","import { EventJSONBase, IEventBase, Point, ShapeTypes } from \"../../interfaces\";\r\n\r\nexport class EventBase implements IEventBase {\r\n    public type: ShapeTypes = ShapeTypes.NONE;    \r\n    public event_name: string;\r\n    public user_name: string;\r\n    public capture_canvas_dimensions: Point;\r\n    public current_canvas_dimensions: Point;\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string) {\r\n        this.current_canvas_dimensions = current_canvas_dimensions;\r\n        this.capture_canvas_dimensions = capture_canvas_dimensions;\r\n        this.event_name = this.getNewEventID();\r\n        this.user_name = user_name;\r\n    }\r\n\r\n    /**\r\n     * Validate if events match based on the name\r\n     * @param other IEventBase\r\n     * @returns boolean\r\n     */\r\n    public isEqual(other: IEventBase) {\r\n        return this.event_name === other.event_name;\r\n    }\r\n\r\n    /**\r\n     * Get a randomized event name for the given event\r\n     * @returns string\r\n     */\r\n    protected getNewEventID() {\r\n        const length = 10;\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const charactersLength = characters.length;\r\n        let counter = 0;\r\n        while (counter < length) {\r\n          result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n          counter += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Render the event onto the canvas\r\n     * @param contextAPI Convext API for the canvas \r\n     */\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D, color: string) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Export the event as a JSON object\r\n     */\r\n    public exportToJson(): EventJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n\r\n","import { IPenEvent, PenJSON, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { Line } from \"../structures/line\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport { EventBase } from \"./base\";\r\n\r\nexport class PenEvent extends EventBase implements IPenEvent {\r\n    public type: ShapeTypes = ShapeTypes.LINE;    \r\n    shape: Line[];\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string, shape: Line[]) {\r\n        super(capture_canvas_dimensions, current_canvas_dimensions, user_name);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        this.shape.forEach(line => line.render(contextAPI, this.capture_canvas_dimensions, this.current_canvas_dimensions));\r\n    }\r\n\r\n    private getPoint(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: any ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }\r\n\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n\r\n        this.shape.forEach((line) => {\r\n            from_point.x = this.getPoint(\"x\", from_point, line.from_point, Math.min);\r\n            from_point.y = this.getPoint(\"y\", from_point, line.from_point, Math.min);\r\n            from_point.x = this.getPoint(\"x\", from_point, line.to_point, Math.min);\r\n            from_point.y = this.getPoint(\"y\", from_point, line.to_point, Math.min);\r\n            \r\n            to_point.x = this.getPoint(\"x\", to_point, line.from_point, Math.max);\r\n            to_point.y = this.getPoint(\"y\", to_point, line.from_point, Math.max);\r\n            to_point.x = this.getPoint(\"x\", to_point, line.to_point, Math.max);\r\n            to_point.y = this.getPoint(\"y\", to_point, line.to_point, Math.max);\r\n        });\r\n\r\n        return { from_point, to_point };\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D, color: string) {        \r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(contextAPI);\r\n\r\n        contextAPI.setLineDash([6]);\r\n        contextAPI.strokeStyle = color;\r\n        contextAPI.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        contextAPI.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.forEach((line) => {\r\n            line.shift(from_point, to_point);\r\n        })\r\n    }\r\n\r\n    public exportToJson(): PenJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            current_canvas_dimensions: this.current_canvas_dimensions,\r\n            shape: this.shape.map(line => line.exportToJson())\r\n        }\r\n    }\r\n}\r\n","import { ISquareEvent, SquareJSON, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { Square } from \"../structures/square\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport { EventBase } from \"./base\";\r\n\r\nexport class SquareEvent extends EventBase implements ISquareEvent {\r\n    public type: ShapeTypes = ShapeTypes.LINE;    \r\n    shape: Square;\r\n\r\n    constructor(capture_canvas_dimensions: Point, current_canvas_dimensions: Point, user_name: string, shape: Square) {\r\n        super(capture_canvas_dimensions, current_canvas_dimensions, user_name);\r\n        this.shape = shape;\r\n    }\r\n\r\n    public render(contextAPI: OffscreenCanvasRenderingContext2D) {\r\n        this.shape.render(contextAPI, this.capture_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    private getPoint(axis: \"x\" | \"y\", existing: Point, candidate: Point, func: any ): number {\r\n        if (existing[axis] === -1) return candidate[axis];\r\n        return func(existing[axis], candidate[axis]);\r\n    }\r\n\r\n    private getBoundingRect(): { from_point: Point, to_point: Point } {\r\n        const from_point = { x: -1, y: -1 };\r\n        const to_point = { x: -1, y: -1 };\r\n        \r\n        from_point.x = this.getPoint(\"x\", from_point, this.shape.from_point, Math.min);\r\n        from_point.y = this.getPoint(\"y\", from_point, this.shape.from_point, Math.min);\r\n        from_point.x = this.getPoint(\"x\", from_point, this.shape.to_point, Math.min);\r\n        from_point.y = this.getPoint(\"y\", from_point, this.shape.to_point, Math.min);\r\n            \r\n        to_point.x = this.getPoint(\"x\", to_point, this.shape.from_point, Math.max);\r\n        to_point.y = this.getPoint(\"y\", to_point, this.shape.from_point, Math.max);\r\n        to_point.x = this.getPoint(\"x\", to_point, this.shape.to_point, Math.max);\r\n        to_point.y = this.getPoint(\"y\", to_point, this.shape.to_point, Math.max);\r\n        \r\n        return { from_point, to_point };\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean {\r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        return (point.x >= from_point.x && point.y >= from_point.y && point.x <= to_point.x && point.y <= to_point.y);\r\n    }\r\n\r\n    public select(contextAPI: OffscreenCanvasRenderingContext2D, color: string) {        \r\n        const {from_point, to_point} = this.getBoundingRect();\r\n\r\n        const fromCoords = normalizeCoordinates(from_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(to_point, this.current_canvas_dimensions, this.capture_canvas_dimensions);  \r\n\r\n        fromCoords.x = fromCoords.x - 10;\r\n        fromCoords.y = fromCoords.y - 10;\r\n        toCoords.x = toCoords.x + 10;\r\n        toCoords.y = toCoords.y + 10;\r\n\r\n        this.render(contextAPI);\r\n\r\n        contextAPI.setLineDash([6]);\r\n        contextAPI.strokeStyle = color;\r\n        contextAPI.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        ); \r\n        contextAPI.setLineDash([0]);\r\n    }\r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.shape.shift(from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): SquareJSON {\r\n        return {\r\n            type: this.type,\r\n            event_name: this.event_name,\r\n            user_name: this.user_name,\r\n            capture_canvas_dimensions: this.capture_canvas_dimensions,\r\n            current_canvas_dimensions: this.current_canvas_dimensions,\r\n            shape: this.shape.exportToJson(),\r\n        }\r\n    }\r\n}\r\n","import { Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { PenEvent } from \"../events/pen\";\r\nimport { SquareEvent } from \"../events/square\";\r\nimport { ShapeBase } from \"../structures/base\";\r\nimport { Line } from \"../structures/line\";\r\nimport { Square } from \"../structures/square\";\r\n\r\nconst DEFAULT_POINT: Point = { x: -1, y: -1 };\r\n\r\nexport class EventManager {\r\n \r\n    user_name: string | null =  null;\r\n    events: EventBase[] = [];\r\n    current_canvas_dimensions: Point = DEFAULT_POINT;\r\n\r\n    public initialiseCanvas(dimensions: Point) {\r\n        this.current_canvas_dimensions = dimensions;\r\n    }    \r\n    public initialiseUser(user_name: string) {\r\n        this.user_name = user_name;\r\n    }    \r\n\r\n    public getEventAgainstPoint(point: Point): EventBase | null {\r\n        let event: EventBase | null = null;        \r\n        for (let idx = this.events.length - 1; idx >= 0; idx-- ) {\r\n            if (this.events[idx].containsPoint(point)) {\r\n                event = this.events[idx];\r\n                break;\r\n            }\r\n        }\r\n        return event;\r\n    }\r\n\r\n    public updateEventAfterMove(event: EventBase) {\r\n        this.events = this.events.filter((evt) => evt.event_name !== event.event_name);\r\n        this.events.push(event);\r\n    }\r\n\r\n    public isInitialised(): boolean {\r\n        return this.user_name !== null;\r\n    }\r\n\r\n    public createEvent(shapeType: ShapeTypes, shape: ShapeBase | ShapeBase[]): EventBase | null {\r\n        if (this.user_name === null) return null;\r\n\r\n        switch (shapeType) {\r\n            case ShapeTypes.LINE: {\r\n                const event = new PenEvent(this.current_canvas_dimensions, this.current_canvas_dimensions, this.user_name, shape as Line[]);\r\n                this.events.push(event);\r\n                return event;\r\n            }\r\n            case ShapeTypes.SQUARE: {\r\n                const event = new SquareEvent(this.current_canvas_dimensions, this.current_canvas_dimensions, this.user_name, shape as Square);\r\n                this.events.push(event);\r\n                return event;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","import { IProperties, Point } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { ShapeBase } from \"../structures/base\";\r\n\r\nconst DEFAULT_POINT = { x: -1, y: -1 };\r\n\r\nexport class RenderManager {\r\n    public offscreen_temporary_canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    private offscreen_canvas: OffscreenCanvasRenderingContext2D | null = null;\r\n    public current_canvas_dimensions: Point = DEFAULT_POINT;    \r\n    private selection_color: string = \"e6e6e6\";\r\n\r\n\r\n    public onSelectionColorChange(color: string) {\r\n        this.selection_color = color;\r\n    }\r\n\r\n    public initialiseCanvas(canvas: OffscreenCanvas, dimensions: Point) {\r\n        const context = canvas.getContext(\"2d\") \r\n        if (context=== null) return;\r\n        this.offscreen_canvas = context as OffscreenCanvasRenderingContext2D;\r\n        this.current_canvas_dimensions = dimensions;\r\n    }    \r\n\r\n    public initialiseLayer(canvas: OffscreenCanvas, dimensions: Point) {\r\n        const context = canvas.getContext(\"2d\") \r\n        if (context=== null) return;\r\n        this.offscreen_temporary_canvas = context as OffscreenCanvasRenderingContext2D;\r\n    }\r\n    public renderShape(shape: ShapeBase): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        shape.render(this.offscreen_canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    public renderShapeOnLayer(shape: ShapeBase): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        shape.render(this.offscreen_temporary_canvas, this.current_canvas_dimensions, this.current_canvas_dimensions);\r\n    }\r\n\r\n    public selectEvent(event: EventBase): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        event.select(this.offscreen_temporary_canvas, this.selection_color);\r\n    }\r\n\r\n    public renderEvent(event: EventBase): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        event.render(this.offscreen_canvas);\r\n    }\r\n\r\n    public renderEventOnLayer(event: EventBase): void {\r\n        this.clearLayer();\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        event.render(this.offscreen_temporary_canvas);\r\n    }    \r\n\r\n    public clearLayer(): void {\r\n        if (this.offscreen_temporary_canvas === null) return;\r\n        this.offscreen_temporary_canvas.clearRect(0, 0, this.current_canvas_dimensions.x, this.current_canvas_dimensions.y);\r\n    }\r\n\r\n    public clearCanvas(): void {\r\n        if (this.offscreen_canvas === null) return;\r\n        this.offscreen_canvas.clearRect(0, 0, this.current_canvas_dimensions.x, this.current_canvas_dimensions.y);\r\n    }    \r\n}","import { IProperties, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport abs from \"../utils/abs\";\r\nimport { EventManager } from \"./events\";\r\nimport { RenderManager } from \"./render\";\r\n\r\nconst DEFAULT_POINT = { x: -1, y: -1 };\r\n\r\n\r\nexport class SelectionManager {\r\n    public active_shape: ShapeTypes = ShapeTypes.NONE;\r\n    public renderManager: RenderManager;\r\n    public eventManager: EventManager;\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private active_event: EventBase | null = null;\r\n    private is_mouse_down: boolean = false;\r\n\r\n    constructor(eventManager: EventManager, renderManager: RenderManager) {\r\n        this.renderManager = renderManager;\r\n        this.eventManager = eventManager;\r\n    }\r\n\r\n\r\n    public reset(): void {\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        if (this.active_event !== null) {\r\n            this.renderManager.renderEvent(this.active_event);\r\n        }\r\n        this.active_event = null;\r\n        this.renderManager.clearLayer();\r\n    }\r\n\r\n    public isEnabled(): boolean {\r\n        return this.active_shape === ShapeTypes.NONE;\r\n    }\r\n\r\n    public onSelectedShapeChange(selected_shape: ShapeTypes) {\r\n        this.active_shape = selected_shape;\r\n        this.reset();\r\n    }\r\n\r\n    public isShiftingEvent(point: Point): boolean {\r\n        return this.active_event !== null && this.is_mouse_down;\r\n    }\r\n\r\n    private shiftingShape(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (isMouseDown) {\r\n            if (this.active_event === null) return null;\r\n            this.active_event.shift(this.last_coordinates, point);\r\n            this.renderManager.renderEventOnLayer(this.active_event);\r\n            this.last_coordinates = point;\r\n            return null;\r\n        } else {\r\n            // Compelte shifting\r\n            if (this.active_event === null) return null;\r\n            const event = this.active_event;\r\n            this.eventManager.updateEventAfterMove(event);\r\n            this.selectEvent(event, point);\r\n            this.is_mouse_down = false;\r\n            return event;\r\n        }\r\n    }\r\n\r\n    private selectEvent(event: EventBase, point: Point) {\r\n        this.renderManager.clearLayer();\r\n        this.renderManager.clearCanvas();\r\n        const remainingEvents = this.eventManager.events.filter((ev) => ev.event_name !== event.event_name);\r\n        remainingEvents.forEach((ev) => {\r\n            this.renderManager.renderEvent(ev);\r\n        });\r\n\r\n        this.renderManager.selectEvent(event);\r\n\r\n        this.active_event = event;\r\n        this.last_coordinates = point;\r\n        this.is_mouse_down = true;        \r\n    }\r\n\r\n    private deselectEvent() {\r\n        this.renderManager.clearLayer();\r\n        this.renderManager.clearCanvas();\r\n        this.eventManager.events.forEach((ev) => {\r\n            this.renderManager.renderEvent(ev);\r\n        });\r\n        this.active_event = null;\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        return null;\r\n    }\r\n\r\n    private selectingShape(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (isMouseDown) {\r\n            // Select event\r\n            const event = this.eventManager.getEventAgainstPoint(point);\r\n            if (event !== null) this.selectEvent(event, point);\r\n            else this.deselectEvent();\r\n\r\n            return event;\r\n        } else {\r\n            this.is_mouse_down = false;\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): EventBase | null {\r\n        if (this.isShiftingEvent(point)) return this.shiftingShape(point, isMouseDown);\r\n        else return this.selectingShape(point, isMouseDown);\r\n    }\r\n    \r\n}","import { Point } from \"../../interfaces\";\r\nimport abs from \"./abs\";\r\n\r\nexport default function shift(point: Point, from_center: Point, to_center: Point): Point {\r\n    const ratio = abs((from_center.y - point.y) / (from_center.x - point.x));\r\n    const distance = Math.sqrt(Math.pow( from_center.y - point.y, 2) +  Math.pow(from_center.x - point.x, 2))\r\n    const c = distance / Math.sqrt( ( Math.pow(ratio, 2) + 1 ))\r\n\r\n    const multiplier = {\r\n        x: point.x < from_center.x ? -1 : 1,\r\n        y: point.y < from_center.y ? -1 : 1,\r\n    }\r\n\r\n    return {\r\n        x: to_center.x + multiplier.x * c,\r\n        y: to_center.y + multiplier.y * ratio * c\r\n\r\n\r\n    }\r\n}","export default function abs(num: number): number {\r\n    if (num < 0)\r\n        return -1 * num;\r\n    return num;\r\n}","import { IShapeBase, IShapeJSONBase, Point } from \"../../interfaces\";\r\n\r\nexport class ShapeBase implements IShapeBase {\r\n    public exportToJson(): IShapeJSONBase {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        throw new Error(\"Not implemented\");\r\n    }    \r\n}","import { ILine, LineJSON, Point } from \"../../interfaces\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport shift from \"../utils/shift\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\nexport class Line extends ShapeBase implements ILine {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);        \r\n\r\n        context.beginPath();\r\n        context.strokeStyle = this.border_color;\r\n        context.moveTo(fromCoords.x, fromCoords.y);\r\n        context.lineTo(toCoords.x, toCoords.y);\r\n        context.closePath();\r\n        context.stroke();                   \r\n    }    \r\n\r\n    public shift (from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): LineJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}","import { ISquare, SquareShapeJSON, Point } from \"../../interfaces\";\r\nimport { normalizeCoordinates } from \"../utils\";\r\nimport shift from \"../utils/shift\";\r\nimport { ShapeBase } from \"./base\";\r\n\r\nexport class Square extends ShapeBase implements ISquare {\r\n    from_point: Point;\r\n    to_point: Point; \r\n    border_color: string;\r\n\r\n    constructor(from_point: Point, to_point: Point, border_color: string) {\r\n        super();\r\n        this.from_point = from_point;\r\n        this.to_point = to_point;\r\n        this.border_color = border_color;\r\n    }\r\n\r\n    public render(context: OffscreenCanvasRenderingContext2D, capture_canvas_dimensions: Point, current_canvas_dimensions: Point): void {\r\n        const fromCoords = normalizeCoordinates(this.from_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        const toCoords = normalizeCoordinates(this.to_point, current_canvas_dimensions, capture_canvas_dimensions);\r\n        context.strokeStyle = this.border_color;\r\n        context.strokeRect(\r\n            fromCoords.x, \r\n            fromCoords.y, \r\n            (toCoords.x - fromCoords.x),\r\n            (toCoords.y - fromCoords.y)\r\n        );                     \r\n    }    \r\n\r\n    public shift(from_point: Point, to_point: Point) {\r\n        this.from_point = shift(this.from_point, from_point, to_point);\r\n        this.to_point = shift(this.to_point, from_point, to_point);\r\n    }\r\n\r\n    public exportToJson(): SquareShapeJSON {\r\n        return {\r\n            from_point: this.from_point,\r\n            to_point: this.to_point,\r\n            border_color: this.border_color,\r\n        }\r\n    }\r\n}\r\n\r\n","import { Point } from \"../../interfaces\";\r\n\r\nexport default function comparePoints(p1: Point, p2: Point) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}","import { IProperties, IPropertiesChange, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { ShapeBase } from \"../structures/base\";\r\nimport { Line } from \"../structures/line\";\r\nimport { RenderManager } from \"./render\";\r\nimport { Square } from \"../structures/square\";\r\nimport comparePoints from \"../utils/comparePoints\";\r\n\r\nconst DEFAULT_POINT: Point = { x: -1, y: -1 };\r\n\r\nexport class ShapeManager {\r\n    public active_shape: ShapeTypes = ShapeTypes.NONE;\r\n    public shape: any = null;\r\n    public renderManager: RenderManager;\r\n    private start_coordinates: Point = DEFAULT_POINT;\r\n    private last_coordinates: Point = DEFAULT_POINT;\r\n    private is_mouse_down: boolean = false;\r\n    private properties: IProperties = {\r\n        borderColor: \"#000\",\r\n    };\r\n\r\n    constructor(renderManager: RenderManager) {\r\n        this.renderManager = renderManager;\r\n    }\r\n\r\n    onPropertiesChange(properties: IPropertiesChange) {\r\n        this.properties = properties;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.last_coordinates = DEFAULT_POINT;\r\n        this.start_coordinates = DEFAULT_POINT;\r\n        this.is_mouse_down = false;\r\n        this.shape = null;\r\n        this.renderManager.clearLayer();        \r\n    }\r\n\r\n    public isEnabled(): boolean {\r\n        return this.active_shape !== ShapeTypes.NONE;\r\n    }\r\n\r\n    public onSelectedShapeChange(selected_shape: ShapeTypes) {\r\n        this.active_shape = selected_shape;\r\n        this.reset();\r\n    }\r\n    \r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean) : ShapeBase | ShapeBase[] | null  {\r\n        let shape = null;\r\n        switch(this.active_shape) {\r\n            case ShapeTypes.LINE: {\r\n                shape = this.captureLine(point, isMouseDown);\r\n                break;\r\n            }\r\n            case ShapeTypes.SQUARE: {\r\n                shape = this.captureSquare(point, isMouseDown);\r\n                break;\r\n            }\r\n        }\r\n        return shape;     \r\n    }\r\n\r\n    private captureLine(point: Point, isMouseDown: boolean): Line[] | null {\r\n        if (comparePoints(this.last_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (isMouseDown) {\r\n                this.last_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n        \r\n        if (isMouseDown) {\r\n            const line = new Line(this.last_coordinates, point, this.properties.borderColor);\r\n                \r\n            if (this.shape === null)    \r\n                this.shape = [];\r\n\r\n            this.shape.push(line);\r\n            this.renderManager.renderShapeOnLayer(line);\r\n            this.last_coordinates = point;\r\n\r\n            return null;\r\n        }\r\n        const shape = (this.shape !== null) ? this.shape : null;\r\n\r\n        this.reset();\r\n        (shape as Line[])?.forEach((line) => this.renderManager.renderShape(line));\r\n\r\n        return shape;\r\n    }\r\n\r\n    private captureSquare(point: Point, isMouseDown: boolean): Square | null {\r\n        if (comparePoints(this.start_coordinates, DEFAULT_POINT) && !this.is_mouse_down) {\r\n            if (isMouseDown) {\r\n                this.start_coordinates = point;\r\n                this.is_mouse_down = true;\r\n            }\r\n            return null;\r\n        }\r\n        \r\n        if (isMouseDown) {\r\n            this.renderManager.clearLayer();\r\n            const square = new Square(this.start_coordinates, point, this.properties.borderColor);\r\n                \r\n            this.shape = square;\r\n            this.renderManager.renderShapeOnLayer(square);\r\n\r\n            return null;\r\n        }\r\n        const shape = (this.shape !== null) ? this.shape : null;\r\n        this.reset();\r\n\r\n        if (shape === null) return null;\r\n\r\n        this.renderManager.renderShape(shape);\r\n        return shape;\r\n    }\r\n}","import { IInitCanvas, IMouseMoveEvent, IInitUser, UserAction, IShapeChange, INewEvent, IInitTemporaryCanvas, IPropertiesChange, IThemeChange } from \"../interfaces\";\r\nimport { Manager } from \"./managers\";\r\n\r\nconst manager = new Manager();\r\n\r\nonmessage = (e: MessageEvent ) => {\r\n    const data = e.data as { action: UserAction, [key: string]: any };\r\n\r\n    switch (data.action) {\r\n        case UserAction.INIT_USER: {        \r\n            manager.onUserInit((data as IInitUser).user_name);\r\n            break;\r\n        } \r\n        case UserAction.INIT_CANVAS: {\r\n            manager.onCanvasInit(\r\n                (data as IInitCanvas).canvas, \r\n                (data as IInitCanvas).dimensions\r\n            );\r\n            break;\r\n        }\r\n        case UserAction.INIT_TEMPORARY_CANVAS: {\r\n            manager.onTemporaryCanvasInit(\r\n                (data as IInitTemporaryCanvas).canvas, \r\n                (data as IInitTemporaryCanvas).dimensions\r\n            );\r\n            break;\r\n        }\r\n        case UserAction.SHAPE_CHANGE: {\r\n            manager.onSelectedShapeChange((data as IShapeChange).shape);\r\n            break;\r\n        }\r\n        case UserAction.MOUSE_MOVE_EVENT: {\r\n            const event = manager.onMouseMoveEvent(\r\n                (data as IMouseMoveEvent).point,\r\n                (data as IMouseMoveEvent).isMouseDown\r\n            );\r\n            if (event !== null) {\r\n                postMessage({\r\n                    type: UserAction.NEW_EVENT_ADDED,\r\n                    event: event.exportToJson(),\r\n                } as INewEvent);\r\n            }\r\n            break;\r\n        }\r\n        case UserAction.PROPERTIES_CHANGE: {\r\n            manager.onPropertiesChange((data as IPropertiesChange));\r\n            break;\r\n        }\r\n        case UserAction.THEME_CHANGE: {\r\n            manager.onThemeChange((data as IThemeChange));\r\n        }\r\n    }\r\n};","import {  IProperties, IPropertiesChange, IThemeChange, Point, ShapeTypes } from \"../../interfaces\";\r\nimport { EventBase } from \"../events/base\";\r\nimport { EventManager } from \"./events\";\r\nimport { RenderManager } from \"./render\";\r\nimport { SelectionManager } from \"./selection\";\r\nimport { ShapeManager } from \"./shape\";\r\n\r\n\r\nexport class Manager {\r\n\r\n    eventManager: EventManager = new EventManager();\r\n    renderManager: RenderManager = new RenderManager();\r\n    shapeManager: ShapeManager = new ShapeManager(this.renderManager);\r\n    selectionManager: SelectionManager = new SelectionManager(this.eventManager, this.renderManager);\r\n\r\n    public onUserInit(user_name: string): void {\r\n        this.eventManager.initialiseUser(user_name);\r\n    }\r\n\r\n    public onCanvasInit(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        this.eventManager.initialiseUser(\"Vatsal\");\r\n        this.renderManager.initialiseCanvas(canvas, dimensions);\r\n        this.eventManager.initialiseCanvas(dimensions);\r\n    }\r\n\r\n    public onTemporaryCanvasInit(canvas: OffscreenCanvas, dimensions: Point): void {\r\n        this.renderManager.initialiseLayer(canvas, dimensions);\r\n    }\r\n\r\n    public onSelectedShapeChange(selectedShape: ShapeTypes): void {\r\n        this.shapeManager.onSelectedShapeChange(selectedShape);\r\n        this.selectionManager.onSelectedShapeChange(selectedShape);\r\n    }\r\n\r\n    public onMouseMoveEvent(point: Point, isMouseDown: boolean): null | EventBase {\r\n        if (this.selectionManager.isEnabled()) return this.onMouseMoveForSelection(point, isMouseDown);\r\n        return this.onMouseMoveForDraw(point, isMouseDown);\r\n    }\r\n\r\n    private onMouseMoveForSelection(point: Point, isMouseDown: boolean): null | EventBase {\r\n        const event = this.selectionManager.onMouseMoveEvent(point, isMouseDown);\r\n        return event;\r\n    }\r\n\r\n    private onMouseMoveForDraw(point: Point, isMouseDown: boolean): null | EventBase {\r\n        const shape = this.shapeManager.onMouseMoveEvent(point, isMouseDown);\r\n\r\n        if (shape === null)\r\n            return null;\r\n\r\n        const event = this.eventManager.createEvent(this.shapeManager.active_shape, shape)\r\n        return event;\r\n    }\r\n\r\n    public onPropertiesChange(properties: IPropertiesChange) {\r\n        this.shapeManager.onPropertiesChange(properties);\r\n    }\r\n\r\n    public onThemeChange(properties: IThemeChange) {\r\n        this.renderManager.onSelectionColorChange(properties.select_color);\r\n    }\r\n}"],"names":["UserAction","ShapeTypes","normalizeCoordinates","coords","currentDimensions","captureDimensions","x","y","EventBase","constructor","capture_canvas_dimensions","current_canvas_dimensions","user_name","type","NONE","event_name","this","getNewEventID","isEqual","other","result","characters","counter","charAt","Math","floor","random","render","contextAPI","Error","select","color","containsPoint","point","shift","from_point","to_point","exportToJson","PenEvent","shape","super","LINE","forEach","line","getPoint","axis","existing","candidate","func","getBoundingRect","min","max","fromCoords","toCoords","setLineDash","strokeStyle","strokeRect","map","SquareEvent","DEFAULT_POINT","EventManager","events","initialiseCanvas","dimensions","initialiseUser","getEventAgainstPoint","event","idx","length","updateEventAfterMove","filter","evt","push","isInitialised","createEvent","shapeType","SQUARE","RenderManager","offscreen_temporary_canvas","offscreen_canvas","selection_color","onSelectionColorChange","canvas","context","getContext","initialiseLayer","renderShape","renderShapeOnLayer","selectEvent","renderEvent","renderEventOnLayer","clearLayer","clearRect","clearCanvas","SelectionManager","eventManager","renderManager","active_shape","last_coordinates","active_event","is_mouse_down","reset","isEnabled","onSelectedShapeChange","selected_shape","isShiftingEvent","shiftingShape","isMouseDown","ev","deselectEvent","selectingShape","onMouseMoveEvent","from_center","to_center","ratio","num","c","sqrt","pow","multiplier","ShapeBase","Line","border_color","beginPath","moveTo","lineTo","closePath","stroke","Square","comparePoints","p1","p2","ShapeManager","start_coordinates","properties","borderColor","onPropertiesChange","captureLine","captureSquare","square","manager","shapeManager","selectionManager","onUserInit","onCanvasInit","onTemporaryCanvasInit","selectedShape","onMouseMoveForSelection","onMouseMoveForDraw","onThemeChange","select_color","onmessage","e","data","action","INIT_USER","INIT_CANVAS","INIT_TEMPORARY_CANVAS","SHAPE_CHANGE","MOUSE_MOVE_EVENT","postMessage","NEW_EVENT_ADDED","PROPERTIES_CHANGE","THEME_CHANGE"],"sourceRoot":""}