import { IShape, IUserEvent, IUserEventJSON, Point, Shapes } from "../../../interfaces";

/** Defines the base class for all events generated by the user */
export class UserEventBase implements IUserEvent {
    
    type: Shapes = Shapes.NONE;
    event_name: string;
    user_name: string;
    shape: IShape | IShape[];
    capture_canvas_dimensions: Point;
    
    constructor(capture_canvas_dimensions: Point, user_name: string, shape: IShape | IShape[]) {
        this.shape = shape;
        this.capture_canvas_dimensions = capture_canvas_dimensions;
        this.event_name = this.getNewEventID();
        this.user_name = user_name;
    }

    public isEqual(other: IUserEvent) {
        return this.event_name === other.event_name;
    }    

    public render (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point): void {
        throw new Error("Not implemented");
    }

    public select (context: OffscreenCanvasRenderingContext2D, current_canvas_dimensions: Point, select_outline_color: string): void {
        throw new Error("Not implemented");
    }

    public exportToJson(): IUserEventJSON {
        throw new Error("Not implemented");
    }

    public containsPoint (point: Point): boolean {
        throw new Error("Not implemented");
    }
    
    public shift (from_point: Point, to_point: Point): void {
        throw new Error("Not implemented");
    }

    /**
     * Get the axis value based on existing & candidate points based on the Math max or min function
     * @param axis Axis x or y
     * @param existing Existing point
     * @param candidate POint to be considered
     * @param func Max or min function
     * @returns new axis value
     */
    protected getAxisValue(axis: "x" | "y", existing: Point, candidate: Point, func: typeof Math.min | typeof Math.max ): number {
        if (existing[axis] === -1) return candidate[axis];
        return func(existing[axis], candidate[axis]);
    }    

    /**
     * Get a randomized event name for the given event
     * @returns string
     */
    private getNewEventID() {
        const length = 10;
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        let counter = 0;
        while (counter < length) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
          counter += 1;
        }
        return result;
    }
}

